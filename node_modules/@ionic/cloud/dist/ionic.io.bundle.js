(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
var request_1 = require('../core/request');
var promise_1 = require('../core/promise');
var core_1 = require('../core/core');
var storage_1 = require('./storage');
var user_1 = require('../core/user');
var util_1 = require('../util/util');
var ANALYTICS_KEY = null;
var DEFER_REGISTER = 'DEFER_REGISTER';
var options = {};
var globalProperties = {};
var globalPropertiesFns = [];
var Analytics = (function () {
    function Analytics(config) {
        this._dispatcher = null;
        this._dispatchIntervalTime = 30;
        this._useEventCaching = true;
        this._serviceHost = core_1.IonicPlatform.config.getURL('analytics');
        this.storage = core_1.IonicPlatform.storage;
        this.cache = new storage_1.BucketStorage('ionic_analytics');
        this._addGlobalPropertyDefaults();
        if (config !== DEFER_REGISTER) {
            this.register(config);
        }
    }
    Analytics.prototype._addGlobalPropertyDefaults = function () {
        this.setGlobalProperties(function (eventCollection, eventData) {
            eventData._user = JSON.parse(JSON.stringify(user_1.User.current()));
            eventData._app = {
                'app_id': core_1.IonicPlatform.config.get('app_id'),
                'analytics_version': core_1.IonicPlatform.version
            };
        });
    };
    Object.defineProperty(Analytics.prototype, "hasValidSettings", {
        get: function () {
            if (!core_1.IonicPlatform.config.get('app_id') || !core_1.IonicPlatform.config.get('api_key')) {
                var msg = 'Ionic Analytics: A valid app_id and api_key are required before you can utilize ' +
                    'analytics properly. See http://docs.ionic.io/v1.0/docs/io-quick-start';
                core_1.IonicPlatform.logger.info(msg);
                return false;
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Analytics.prototype, "dispatchInterval", {
        get: function () {
            return this._dispatchIntervalTime;
        },
        set: function (value) {
            var self = this;
            // Set how often we should send batched events, in seconds.
            // Set this to 0 to disable event caching
            this._dispatchIntervalTime = value;
            // Clear the existing interval
            if (this._dispatcher) {
                window.clearInterval(this._dispatcher);
            }
            if (value > 0) {
                this._dispatcher = window.setInterval(function () { self._dispatchQueue(); }, value * 1000);
                this._useEventCaching = true;
            }
            else {
                this._useEventCaching = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Analytics.prototype._enqueueEvent = function (collectionName, eventData) {
        if (options.dryRun) {
            core_1.IonicPlatform.logger.info('Ionic Analytics: event recieved but not sent (dryRun active):');
            core_1.IonicPlatform.logger.info('Ionic Analytics:', collectionName);
            core_1.IonicPlatform.logger.info('Ionic Analytics:', eventData);
            return;
        }
        core_1.IonicPlatform.logger.info('Ionic Analytics: enqueuing event to send later:');
        core_1.IonicPlatform.logger.info('Ionic Analytics:', collectionName);
        core_1.IonicPlatform.logger.info('Ionic Analytics:', eventData);
        // Add timestamp property to the data
        if (!eventData.keen) {
            eventData.keen = {};
        }
        eventData.keen.timestamp = new Date().toISOString();
        // Add the data to the queue
        var eventQueue = this.cache.get('event_queue') || {};
        if (!eventQueue[collectionName]) {
            eventQueue[collectionName] = [];
        }
        eventQueue[collectionName].push(eventData);
        // Write the queue to disk
        this.cache.set('event_queue', eventQueue);
    };
    Analytics.prototype._requestAnalyticsKey = function () {
        var requestOptions = {
            'method': 'GET',
            'json': true,
            'uri': core_1.IonicPlatform.config.getURL('api') + '/api/v1/app/' + core_1.IonicPlatform.config.get('app_id') + '/keys/write',
            'headers': {
                'Authorization': 'basic ' + btoa(core_1.IonicPlatform.config.get('app_id') + ':' + core_1.IonicPlatform.config.get('api_key'))
            }
        };
        return request_1.request(requestOptions);
    };
    Analytics.prototype._postEvent = function (name, data) {
        var payload = {
            'name': [data]
        };
        if (!ANALYTICS_KEY) {
            core_1.IonicPlatform.logger.error('Ionic Analytics: Cannot send events to the analytics server without an Analytics key.');
        }
        var requestOptions = {
            'method': 'POST',
            'url': this._serviceHost + '/api/v1/events/' + core_1.IonicPlatform.config.get('app_id'),
            'json': payload,
            'headers': {
                'Authorization': ANALYTICS_KEY
            }
        };
        return request_1.request(requestOptions);
    };
    Analytics.prototype._postEvents = function (events) {
        if (!ANALYTICS_KEY) {
            core_1.IonicPlatform.logger.info('Ionic Analytics: Cannot send events to the analytics server without an Analytics key.');
        }
        var requestOptions = {
            'method': 'POST',
            'url': this._serviceHost + '/api/v1/events/' + core_1.IonicPlatform.config.get('app_id'),
            'json': events,
            'headers': {
                'Authorization': ANALYTICS_KEY
            }
        };
        return request_1.request(requestOptions);
    };
    Analytics.prototype._dispatchQueue = function () {
        var self = this;
        var eventQueue = this.cache.get('event_queue') || {};
        if (Object.keys(eventQueue).length === 0) {
            return;
        }
        if (!core_1.IonicPlatform.device.isConnectedToNetwork()) {
            return;
        }
        self.storage.lockedAsyncCall(self.cache.scopedKey('event_dispatch'), function () {
            return self._postEvents(eventQueue);
        }).then(function () {
            self.cache.set('event_queue', {});
            core_1.IonicPlatform.logger.info('Ionic Analytics: sent events');
            core_1.IonicPlatform.logger.info('Ionic Analytics:', eventQueue);
        }, function (err) {
            self._handleDispatchError(err, this, eventQueue);
        });
    };
    Analytics.prototype._getRequestStatusCode = function (request) {
        var responseCode = null;
        if (request && request.requestInfo._lastResult && request.requestInfo._lastResult.status) {
            responseCode = request.requestInfo._lastResult.status;
        }
        return responseCode;
    };
    Analytics.prototype._handleDispatchError = function (error, request, eventQueue) {
        var responseCode = this._getRequestStatusCode(request);
        if (error === 'last_call_interrupted') {
            this.cache.set('event_queue', {});
        }
        else {
            // If we didn't connect to the server at all -> keep events
            if (!responseCode) {
                core_1.IonicPlatform.logger.error('Ionic Analytics: Error sending analytics data: Failed to connect to analytics server.');
            }
            else {
                this.cache.set('event_queue', {});
                core_1.IonicPlatform.logger.error('Ionic Analytics: Error sending analytics data: Server responded with error');
                core_1.IonicPlatform.logger.error('Ionic Analytics:', eventQueue);
            }
        }
    };
    Analytics.prototype._handleRegisterError = function (error, request) {
        var responseCode = this._getRequestStatusCode(request);
        var docs = ' See http://docs.ionic.io/v1.0/docs/io-quick-start';
        switch (responseCode) {
            case 401:
                core_1.IonicPlatform.logger.error('Ionic Analytics: The api key and app id you provided did not register on the server. ' + docs);
                break;
            case 404:
                core_1.IonicPlatform.logger.error('Ionic Analytics: The app id you provided ("' + core_1.IonicPlatform.config.get('app_id') + '") was not found.' + docs);
                break;
            default:
                core_1.IonicPlatform.logger.error('Ionic Analytics: Unable to request analytics key.');
                core_1.IonicPlatform.logger.error('Ionic Analytics:', error);
                break;
        }
    };
    /**
     * Registers an analytics key
     *
     * @param {object} opts Registration options
     * @return {Promise} The register promise
     */
    Analytics.prototype.register = function (opts) {
        var self = this;
        var deferred = new promise_1.DeferredPromise();
        if (!this.hasValidSettings) {
            deferred.reject(false);
            return deferred.promise;
        }
        options = opts || {};
        if (options.silent) {
            core_1.IonicPlatform.logger.silent = true;
        }
        else {
            core_1.IonicPlatform.logger.silent = false;
        }
        if (options.dryRun) {
            core_1.IonicPlatform.logger.info('Ionic Analytics: dryRun mode is active. Analytics will not send any events.');
        }
        this._requestAnalyticsKey().then(function (result) {
            ANALYTICS_KEY = result.payload.write_key;
            core_1.IonicPlatform.logger.info('Ionic Analytics: successfully registered analytics key');
            self.dispatchInterval = self.dispatchInterval;
            deferred.resolve(true);
        }, function (error) {
            self._handleRegisterError(error, this);
            deferred.reject(false);
        });
        return deferred.promise;
    };
    Analytics.prototype.setGlobalProperties = function (prop) {
        var propType = (typeof prop);
        switch (propType) {
            case 'object':
                for (var key in prop) {
                    if (!prop.hasOwnProperty(key)) {
                        continue;
                    }
                    globalProperties[key] = prop[key];
                }
                break;
            case 'function':
                globalPropertiesFns.push(prop);
                break;
            default:
                core_1.IonicPlatform.logger.error('Ionic Analytics: setGlobalProperties parameter must be an object or function.');
                break;
        }
    };
    Analytics.prototype.track = function (eventCollection, eventData) {
        if (!this.hasValidSettings) {
            return;
        }
        if (!eventData) {
            eventData = {};
        }
        else {
            // Clone the event data to avoid modifying it
            eventData = util_1.deepExtend({}, eventData);
        }
        for (var key in globalProperties) {
            if (!globalProperties.hasOwnProperty(key)) {
                continue;
            }
            if (eventData[key] === void 0) {
                eventData[key] = globalProperties[key];
            }
        }
        for (var i = 0; i < globalPropertiesFns.length; i++) {
            var fn = globalPropertiesFns[i];
            fn.call(null, eventCollection, eventData);
        }
        if (this._useEventCaching) {
            this._enqueueEvent(eventCollection, eventData);
        }
        else {
            if (options.dryRun) {
                core_1.IonicPlatform.logger.info('Ionic Analytics: dryRun active, will not send event');
                core_1.IonicPlatform.logger.info('Ionic Analytics:', eventCollection);
                core_1.IonicPlatform.logger.info('Ionic Analytics:', eventData);
            }
            else {
                this._postEvent(eventCollection, eventData);
            }
        }
    };
    Analytics.prototype.unsetGlobalProperty = function (prop) {
        var propType = (typeof prop);
        switch (propType) {
            case 'string':
                delete globalProperties[prop];
                break;
            case 'function':
                var i = globalPropertiesFns.indexOf(prop);
                if (i === -1) {
                    core_1.IonicPlatform.logger.error('Ionic Analytics: The function passed to unsetGlobalProperty was not a global property.');
                }
                globalPropertiesFns.splice(i, 1);
                break;
            default:
                core_1.IonicPlatform.logger.error('Ionic Analytics: unsetGlobalProperty parameter must be a string or function.');
                break;
        }
    };
    return Analytics;
}());
exports.Analytics = Analytics;

},{"../core/core":11,"../core/promise":17,"../core/request":18,"../core/user":20,"../util/util":36,"./storage":4}],2:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./analytics'));
__export(require('./serializers'));
__export(require('./storage'));

},{"./analytics":1,"./serializers":3,"./storage":4}],3:[function(require,module,exports){
"use strict";
var DOMSerializer = (function () {
    function DOMSerializer() {
    }
    DOMSerializer.prototype.elementSelector = function (element) {
        // iterate up the dom
        var selectors = [];
        while (element.tagName !== 'HTML') {
            var selector = element.tagName.toLowerCase();
            var id = element.getAttribute('id');
            if (id) {
                selector += '#' + id;
            }
            var className = element.className;
            if (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    var c = classes[i];
                    if (c) {
                        selector += '.' + c;
                    }
                }
            }
            if (!element.parentNode) {
                return null;
            }
            var childIndex = Array.prototype.indexOf.call(element.parentNode.children, element);
            selector += ':nth-child(' + (childIndex + 1) + ')';
            element = element.parentNode;
            selectors.push(selector);
        }
        return selectors.reverse().join('>');
    };
    DOMSerializer.prototype.elementName = function (element) {
        // 1. ion-track-name directive
        var name = element.getAttribute('ion-track-name');
        if (name) {
            return name;
        }
        // 2. id
        var id = element.getAttribute('id');
        if (id) {
            return id;
        }
        // 3. no unique identifier --> return null
        return null;
    };
    return DOMSerializer;
}());
exports.DOMSerializer = DOMSerializer;

},{}],4:[function(require,module,exports){
"use strict";
var core_1 = require('../core/core');
var BucketStorage = (function () {
    function BucketStorage(name) {
        this.name = name;
        this.baseStorage = core_1.IonicPlatform.storage;
    }
    BucketStorage.prototype.get = function (key) {
        return this.baseStorage.retrieveObject(this.scopedKey(key));
    };
    BucketStorage.prototype.set = function (key, value) {
        return this.baseStorage.storeObject(this.scopedKey(key), value);
    };
    BucketStorage.prototype.scopedKey = function (key) {
        return this.name + '_' + key + '_' + core_1.IonicPlatform.config.get('app_id');
    };
    return BucketStorage;
}());
exports.BucketStorage = BucketStorage;

},{"../core/core":11}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var promise_1 = require('../core/promise');
var core_1 = require('../core/core');
var storage_1 = require('../core/storage');
var user_1 = require('../core/user');
var authModules = {};
var authToken;
var TempTokenContext = (function () {
    function TempTokenContext() {
        this.storage = new storage_1.SessionStorageStrategy();
    }
    Object.defineProperty(TempTokenContext.prototype, "label", {
        get: function () {
            return 'ionic_io_auth_' + core_1.IonicPlatform.config.get('app_id');
        },
        enumerable: true,
        configurable: true
    });
    TempTokenContext.prototype.delete = function () {
        this.storage.remove(this.label);
    };
    TempTokenContext.prototype.store = function (token) {
        this.storage.set(this.label, token);
    };
    TempTokenContext.prototype.getRawData = function () {
        return this.storage.get(this.label);
    };
    return TempTokenContext;
}());
exports.TempTokenContext = TempTokenContext;
var TokenContext = (function () {
    function TokenContext() {
        this.storage = new storage_1.LocalStorageStrategy();
    }
    Object.defineProperty(TokenContext.prototype, "label", {
        get: function () {
            return 'ionic_io_auth_' + core_1.IonicPlatform.config.get('app_id');
        },
        enumerable: true,
        configurable: true
    });
    TokenContext.prototype.delete = function () {
        this.storage.remove(tokenContext.label);
    };
    TokenContext.prototype.store = function (token) {
        this.storage.set(tokenContext.label, token);
    };
    TokenContext.prototype.getRawData = function () {
        return this.storage.get(tokenContext.label);
    };
    return TokenContext;
}());
exports.TokenContext = TokenContext;
var tempTokenContext = new TempTokenContext();
var tokenContext = new TokenContext();
function storeToken(options, token) {
    if (options === void 0) { options = {}; }
    var originalToken = authToken;
    authToken = token;
    if (options.remember) {
        tokenContext.store(authToken);
    }
    else {
        tempTokenContext.store(authToken);
    }
    core_1.IonicPlatform.emitter.emit('auth:token-changed', { 'old': originalToken, 'new': authToken });
}
function getAuthErrorDetails(err) {
    var details = [];
    try {
        details = err.response.body.error.details;
    }
    catch (e) {
        e;
    }
    return details;
}
var Auth = (function () {
    function Auth() {
    }
    Auth.isAuthenticated = function () {
        var token = tokenContext.getRawData();
        var tempToken = tempTokenContext.getRawData();
        if (tempToken || token) {
            return true;
        }
        return false;
    };
    Auth.login = function (moduleId, options, data) {
        if (options === void 0) { options = {}; }
        var deferred = new promise_1.DeferredPromise();
        var context = authModules[moduleId] || false;
        if (!context) {
            throw new Error('Authentication class is invalid or missing:' + context);
        }
        context.authenticate.apply(context, [options, data]).then(function () {
            user_1.User.self().then(function (user) {
                deferred.resolve(user);
            }, function (err) {
                deferred.reject(err);
            });
        }, function (err) {
            deferred.reject(err);
        });
        return deferred.promise;
    };
    Auth.signup = function (data) {
        var context = authModules['basic'] || false;
        if (!context) {
            throw new Error('Authentication class is invalid or missing:' + context);
        }
        return context.signup.apply(context, [data]);
    };
    Auth.logout = function () {
        tokenContext.delete();
        tempTokenContext.delete();
        user_1.User.current().clear();
    };
    Auth.register = function (moduleId, module) {
        if (!authModules[moduleId]) {
            authModules[moduleId] = module;
        }
    };
    Auth.getUserToken = function () {
        var usertoken = tokenContext.getRawData();
        var temptoken = tempTokenContext.getRawData();
        var token = temptoken || usertoken;
        return token;
    };
    return Auth;
}());
exports.Auth = Auth;
var AuthType = (function () {
    function AuthType(client) {
        this.client = client;
        this.client = client;
    }
    AuthType.prototype.inAppBrowserFlow = function (authOptions, options, data) {
        if (authOptions === void 0) { authOptions = {}; }
        var deferred = new promise_1.DeferredPromise();
        if (!window || !window.cordova || !window.cordova.InAppBrowser) {
            deferred.reject('Missing InAppBrowser plugin');
        }
        else {
            var method = options.uri_method ? options.uri_method : 'POST';
            var provider = options.provider ? '/' + options.provider : '';
            this.client.request(method, "/auth/login" + provider)
                .send({
                'app_id': core_1.IonicPlatform.config.get('app_id'),
                'callback': options.callback_uri || window.location.href,
                'data': data
            })
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    var loc = res.payload.data.url;
                    var tempBrowser = window.cordova.InAppBrowser.open(loc, '_blank', 'location=no,clearcache=yes,clearsessioncache=yes');
                    tempBrowser.addEventListener('loadstart', function (data) {
                        if (data.url.slice(0, 20) === 'http://auth.ionic.io') {
                            var queryString = data.url.split('#')[0].split('?')[1];
                            var paramParts = queryString.split('&');
                            var params = {};
                            for (var i = 0; i < paramParts.length; i++) {
                                var part = paramParts[i].split('=');
                                params[part[0]] = part[1];
                            }
                            storeToken(authOptions, params.token);
                            tempBrowser.close();
                            tempBrowser = null;
                            deferred.resolve(true);
                        }
                    });
                }
            });
        }
        return deferred.promise;
    };
    return AuthType;
}());
var BasicAuth = (function (_super) {
    __extends(BasicAuth, _super);
    function BasicAuth() {
        _super.apply(this, arguments);
    }
    BasicAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        var deferred = new promise_1.DeferredPromise();
        this.client.post('/auth/login')
            .send({
            'app_id': core_1.IonicPlatform.config.get('app_id'),
            'email': data.email,
            'password': data.password
        })
            .end(function (err, res) {
            if (err) {
                deferred.reject(err);
            }
            else {
                storeToken(options, res.body.data.token);
                deferred.resolve(true);
            }
        });
        return deferred.promise;
    };
    BasicAuth.prototype.signup = function (data) {
        var deferred = new promise_1.DeferredPromise();
        var userData = {
            'app_id': core_1.IonicPlatform.config.get('app_id'),
            'email': data.email,
            'password': data.password
        };
        // optional details
        if (data.username) {
            userData.username = data.username;
        }
        if (data.image) {
            userData.image = data.image;
        }
        if (data.name) {
            userData.name = data.name;
        }
        if (data.custom) {
            userData.custom = data.custom;
        }
        this.client.post('/auth/users')
            .send(userData)
            .end(function (err, res) {
            if (err) {
                var errors = [];
                var details = getAuthErrorDetails(err);
                if (details instanceof Array) {
                    for (var i = 0; i < details.length; i++) {
                        var detail = details[i];
                        if (typeof detail === 'object') {
                            if (detail.error_type) {
                                errors.push(detail.error_type + '_' + detail.parameter);
                            }
                        }
                    }
                }
                deferred.reject({ 'errors': errors });
            }
            else {
                deferred.resolve(true);
            }
        });
        return deferred.promise;
    };
    return BasicAuth;
}(AuthType));
var CustomAuth = (function (_super) {
    __extends(CustomAuth, _super);
    function CustomAuth() {
        _super.apply(this, arguments);
    }
    CustomAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'custom' }, data);
    };
    return CustomAuth;
}(AuthType));
var TwitterAuth = (function (_super) {
    __extends(TwitterAuth, _super);
    function TwitterAuth() {
        _super.apply(this, arguments);
    }
    TwitterAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'twitter' }, data);
    };
    return TwitterAuth;
}(AuthType));
var FacebookAuth = (function (_super) {
    __extends(FacebookAuth, _super);
    function FacebookAuth() {
        _super.apply(this, arguments);
    }
    FacebookAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'facebook' }, data);
    };
    return FacebookAuth;
}(AuthType));
var GithubAuth = (function (_super) {
    __extends(GithubAuth, _super);
    function GithubAuth() {
        _super.apply(this, arguments);
    }
    GithubAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'github' }, data);
    };
    return GithubAuth;
}(AuthType));
var GoogleAuth = (function (_super) {
    __extends(GoogleAuth, _super);
    function GoogleAuth() {
        _super.apply(this, arguments);
    }
    GoogleAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'google' }, data);
    };
    return GoogleAuth;
}(AuthType));
var InstagramAuth = (function (_super) {
    __extends(InstagramAuth, _super);
    function InstagramAuth() {
        _super.apply(this, arguments);
    }
    InstagramAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'instagram' }, data);
    };
    return InstagramAuth;
}(AuthType));
var LinkedInAuth = (function (_super) {
    __extends(LinkedInAuth, _super);
    function LinkedInAuth() {
        _super.apply(this, arguments);
    }
    LinkedInAuth.prototype.authenticate = function (options, data) {
        if (options === void 0) { options = {}; }
        return this.inAppBrowserFlow(options, { 'provider': 'linkedin' }, data);
    };
    return LinkedInAuth;
}(AuthType));
Auth.register('basic', new BasicAuth(core_1.IonicPlatform.client));
Auth.register('custom', new CustomAuth(core_1.IonicPlatform.client));
Auth.register('facebook', new FacebookAuth(core_1.IonicPlatform.client));
Auth.register('github', new GithubAuth(core_1.IonicPlatform.client));
Auth.register('google', new GoogleAuth(core_1.IonicPlatform.client));
Auth.register('instagram', new InstagramAuth(core_1.IonicPlatform.client));
Auth.register('linkedin', new LinkedInAuth(core_1.IonicPlatform.client));
Auth.register('twitter', new TwitterAuth(core_1.IonicPlatform.client));

},{"../core/core":11,"../core/promise":17,"../core/storage":19,"../core/user":20}],6:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./auth'));

},{"./auth":5}],7:[function(require,module,exports){
"use strict";
var core_1 = require('./core');
var privateData = {};
function privateVar(key) {
    return privateData[key] || null;
}
var App = (function () {
    function App(appId, apiKey) {
        if (!appId || appId === '') {
            core_1.IonicPlatform.logger.info('Ionic App: No app_id was provided');
            return;
        }
        if (!apiKey || apiKey === '') {
            core_1.IonicPlatform.logger.info('Ionic App: No api_key was provided');
            return;
        }
        privateData.id = appId;
        privateData.apiKey = apiKey;
        // other config value reference
        this.devPush = null;
        this.gcmKey = null;
    }
    Object.defineProperty(App.prototype, "id", {
        get: function () {
            return privateVar('id');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(App.prototype, "apiKey", {
        get: function () {
            return privateVar('apiKey');
        },
        enumerable: true,
        configurable: true
    });
    App.prototype.toString = function () {
        return '<App [\'' + this.id + '\'>';
    };
    return App;
}());
exports.App = App;

},{"./core":11}],8:[function(require,module,exports){
"use strict";
var request = require('superagent');
var Client = (function () {
    function Client(baseUrl, token, req // TODO: use superagent types
        ) {
        this.baseUrl = baseUrl;
        this.token = token;
        this.req = req;
        if (typeof req === 'undefined') {
            req = request;
        }
        this.baseUrl = baseUrl;
        this.token = token;
        this.req = req;
    }
    Client.prototype.get = function (endpoint) {
        return this.supplement(this.req.get, endpoint);
    };
    Client.prototype.post = function (endpoint) {
        return this.supplement(this.req.post, endpoint);
    };
    Client.prototype.put = function (endpoint) {
        return this.supplement(this.req.put, endpoint);
    };
    Client.prototype.patch = function (endpoint) {
        return this.supplement(this.req.patch, endpoint);
    };
    Client.prototype.delete = function (endpoint) {
        return this.supplement(this.req.delete, endpoint);
    };
    Client.prototype.request = function (method, endpoint) {
        return this.supplement(this.req.bind(method), endpoint);
    };
    Client.prototype.supplement = function (fn, endpoint) {
        if (endpoint.substring(0, 1) !== '/') {
            throw Error('endpoint must start with leading slash');
        }
        var req = fn(this.baseUrl + endpoint);
        if (this.token) {
            req.set('Authorization', "Bearer " + this.token);
        }
        return req;
    };
    return Client;
}());
exports.Client = Client;

},{"superagent":37}],9:[function(require,module,exports){
"use strict";
var Config = (function () {
    function Config() {
        this.locations = {
            'api': 'https://apps.ionic.io',
            'push': 'https://push.ionic.io',
            'analytics': 'https://analytics.ionic.io',
            'deploy': 'https://apps.ionic.io',
            'platform-api': 'https://api.ionic.io'
        };
    }
    Config.prototype.register = function (settings) {
        this.settings = settings;
    };
    Config.prototype.get = function (name) {
        if (!this.settings) {
            return undefined;
        }
        return this.settings[name];
    };
    Config.prototype.getURL = function (name) {
        var devLocations = this.settings && this.settings['dev_locations'] || {};
        if (devLocations[name]) {
            return devLocations[name];
        }
        return this.locations[name];
    };
    return Config;
}());
exports.Config = Config;
exports.config = new Config();

},{}],10:[function(require,module,exports){
"use strict";
var Cordova = (function () {
    function Cordova(device, logger) {
        this.device = device;
        this.logger = logger;
        this.device = device;
        this.logger = logger;
    }
    Cordova.prototype.load = function () {
        if (!this.isAvailable()) {
            var cordovaScript = document.createElement('script');
            var cordovaSrc = 'cordova.js';
            switch (this.device.deviceType) {
                case 'android':
                    if (window.location.href.substring(0, 4) === 'file') {
                        cordovaSrc = 'file:///android_asset/www/cordova.js';
                    }
                    break;
                case 'ipad':
                case 'iphone':
                    try {
                        var resource = window.location.search.match(/cordova_js_bootstrap_resource=(.*?)(&|#|$)/i);
                        if (resource) {
                            cordovaSrc = decodeURI(resource[1]);
                        }
                    }
                    catch (e) {
                        this.logger.info('Ionic Cordova: could not find cordova_js_bootstrap_resource query param');
                        this.logger.info('Ionic Cordova:', e);
                    }
                    break;
                default:
                    break;
            }
            cordovaScript.setAttribute('src', cordovaSrc);
            document.head.appendChild(cordovaScript);
            this.logger.info('Ionic Cordova: injecting cordova.js');
        }
    };
    Cordova.prototype.isAvailable = function () {
        this.logger.info('Ionic Cordova: searching for cordova.js');
        if (typeof cordova !== 'undefined') {
            this.logger.info('Ionic Cordova: cordova.js has already been loaded');
            return true;
        }
        var scripts = document.getElementsByTagName('script');
        var len = scripts.length;
        for (var i = 0; i < len; i++) {
            var script = scripts[i].getAttribute('src');
            if (script) {
                var parts = script.split('/');
                var partsLength = 0;
                try {
                    partsLength = parts.length;
                    if (parts[partsLength - 1] === 'cordova.js') {
                        this.logger.info('Ionic Cordova: cordova.js has previously been included.');
                        return true;
                    }
                }
                catch (e) {
                    this.logger.info('Ionic Cordova: encountered error while testing for cordova.js presence, ' + e.toString());
                }
            }
        }
        return false;
    };
    return Cordova;
}());
exports.Cordova = Cordova;

},{}],11:[function(require,module,exports){
"use strict";
var client_1 = require('./client');
var cordova_1 = require('./cordova');
var device_1 = require('./device');
var events_1 = require('./events');
var storage_1 = require('./storage');
var logger_1 = require('./logger');
var config_1 = require('./config');
var Core = (function () {
    function Core() {
        this.pluginsReady = false;
        this._version = '0.8.0-beta.7';
        this.config = config_1.config;
        this.logger = new logger_1.Logger();
        this.client = new client_1.Client(this.config.getURL('platform-api'));
        this.device = new device_1.Device();
        this.cordova = new cordova_1.Cordova(this.device, this.logger);
        this.emitter = new events_1.EventEmitter();
        this.storage = new storage_1.Storage();
        this.cordova.load();
        this.registerEventHandlers();
    }
    Core.prototype.init = function (cfg) {
        this.config.register(cfg);
        this.logger.info('Ionic Core: init');
        this.emitter.emit('core:init');
    };
    Object.defineProperty(Core.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    Core.prototype.registerEventHandlers = function () {
        var _this = this;
        this.emitter.on('auth:token-changed', function (data) {
            _this.client.token = data['new'];
        });
        this.emitter.on('core:init', function (data) {
            _this.client.baseUrl = _this.config.getURL('platform-api');
        });
        if (this.device.deviceType === 'unknown') {
            this.logger.info('Ionic Core: attempting to mock plugins');
            this.pluginsReady = true;
            this.emitter.emit('device:ready');
        }
        else {
            document.addEventListener('deviceready', function () {
                _this.logger.info('Ionic Core: plugins are ready');
                _this.pluginsReady = true;
                _this.emitter.emit('device:ready');
            }, false);
        }
    };
    /**
     * Fire a callback when core + plugins are ready. This will fire immediately if
     * the components have already become available.
     *
     * @param {function} callback function to fire off
     * @return {void}
     */
    Core.prototype.onReady = function (callback) {
        var _this = this;
        if (this.pluginsReady) {
            callback(this);
        }
        else {
            this.emitter.on('device:ready', function () {
                callback(_this);
            });
        }
    };
    return Core;
}());
exports.Core = Core;
exports.IonicPlatform = new Core();

},{"./client":8,"./config":9,"./cordova":10,"./device":13,"./events":14,"./logger":16,"./storage":19}],12:[function(require,module,exports){
"use strict";
var dataTypeMapping = {};
var DataTypeSchema = (function () {
    function DataTypeSchema(properties) {
        this.data = {};
        this.setProperties(properties);
    }
    DataTypeSchema.prototype.setProperties = function (properties) {
        if (properties instanceof Object) {
            for (var x in properties) {
                this.data[x] = properties[x];
            }
        }
    };
    DataTypeSchema.prototype.toJSON = function () {
        var data = this.data;
        return {
            '__Ionic_DataTypeSchema': data.name,
            'value': data.value
        };
    };
    DataTypeSchema.prototype.isValid = function () {
        if (this.data.name && this.data.value) {
            return true;
        }
        return false;
    };
    return DataTypeSchema;
}());
exports.DataTypeSchema = DataTypeSchema;
var DataType = (function () {
    function DataType() {
    }
    DataType.get = function (name, value) {
        if (dataTypeMapping[name]) {
            return new dataTypeMapping[name](value);
        }
        return false;
    };
    DataType.getMapping = function () {
        return dataTypeMapping;
    };
    Object.defineProperty(DataType, "Schema", {
        get: function () {
            return DataTypeSchema;
        },
        enumerable: true,
        configurable: true
    });
    DataType.register = function (name, cls) {
        dataTypeMapping[name] = cls;
    };
    return DataType;
}());
exports.DataType = DataType;
var UniqueArray = (function () {
    function UniqueArray(value) {
        this.data = [];
        if (value instanceof Array) {
            for (var x in value) {
                this.push(value[x]);
            }
        }
    }
    UniqueArray.prototype.toJSON = function () {
        var data = this.data;
        var schema = new DataTypeSchema({ 'name': 'UniqueArray', 'value': data });
        return schema.toJSON();
    };
    UniqueArray.fromStorage = function (value) {
        return new UniqueArray(value);
    };
    UniqueArray.prototype.push = function (value) {
        if (this.data.indexOf(value) === -1) {
            this.data.push(value);
        }
    };
    UniqueArray.prototype.pull = function (value) {
        var index = this.data.indexOf(value);
        this.data.splice(index, 1);
    };
    return UniqueArray;
}());
exports.UniqueArray = UniqueArray;
DataType.register('UniqueArray', UniqueArray);

},{}],13:[function(require,module,exports){
"use strict";
var Device = (function () {
    function Device() {
        this.deviceType = this.determineDeviceType();
    }
    /**
     * Check if the device is an Android device
     * @return {boolean} True if Android, false otherwise
     */
    Device.prototype.isAndroid = function () {
        return this.deviceType === 'android';
    };
    /**
     * Check if the device is an iOS device
     * @return {boolean} True if iOS, false otherwise
     */
    Device.prototype.isIOS = function () {
        return this.deviceType === 'iphone' || this.deviceType === 'ipad';
    };
    Device.prototype.isConnectedToNetwork = function (strictMode) {
        if (typeof strictMode === 'undefined') {
            strictMode = false;
        }
        if (typeof navigator.connection === 'undefined' ||
            typeof navigator.connection.type === 'undefined' ||
            typeof Connection === 'undefined') {
            if (!strictMode) {
                return true;
            }
            return false;
        }
        switch (navigator.connection.type) {
            case Connection.ETHERNET:
            case Connection.WIFI:
            case Connection.CELL_2G:
            case Connection.CELL_3G:
            case Connection.CELL_4G:
            case Connection.CELL:
                return true;
            default:
                return false;
        }
    };
    /**
     * Determine the device type via the user agent string
     * @return {string} name of device platform or 'unknown' if unable to identify the device
     */
    Device.prototype.determineDeviceType = function () {
        var agent = navigator.userAgent;
        var ipad = agent.match(/iPad/i);
        if (ipad && (ipad[0].toLowerCase() === 'ipad')) {
            return 'ipad';
        }
        var iphone = agent.match(/iPhone/i);
        if (iphone && (iphone[0].toLowerCase() === 'iphone')) {
            return 'iphone';
        }
        var android = agent.match(/Android/i);
        if (android && (android[0].toLowerCase() === 'android')) {
            return 'android';
        }
        return 'unknown';
    };
    return Device;
}());
exports.Device = Device;

},{}],14:[function(require,module,exports){
"use strict";
var EventEmitter = (function () {
    function EventEmitter() {
        this.eventHandlers = {};
    }
    EventEmitter.prototype.on = function (event, callback) {
        if (typeof this.eventHandlers[event] === 'undefined') {
            this.eventHandlers[event] = [];
        }
        this.eventHandlers[event].push(callback);
    };
    EventEmitter.prototype.emit = function (event, data) {
        if (data === void 0) { data = null; }
        if (typeof this.eventHandlers[event] === 'undefined') {
            this.eventHandlers[event] = [];
        }
        for (var _i = 0, _a = this.eventHandlers[event]; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback(data);
        }
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;

},{}],15:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./app'));
__export(require('./core'));
__export(require('./data-types'));
__export(require('./events'));
__export(require('./logger'));
__export(require('./promise'));
__export(require('./request'));
__export(require('./config'));
__export(require('./storage'));
__export(require('./user'));
__export(require('./client'));

},{"./app":7,"./client":8,"./config":9,"./core":11,"./data-types":12,"./events":14,"./logger":16,"./promise":17,"./request":18,"./storage":19,"./user":20}],16:[function(require,module,exports){
"use strict";
var Logger = (function () {
    function Logger() {
        this.silent = false;
        this.outfn = console.log.bind(console);
        this.errfn = console.error.bind(console);
    }
    Logger.prototype.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!this.silent) {
            this.outfn.apply(this, [message].concat(optionalParams));
        }
    };
    Logger.prototype.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!this.silent) {
            this.outfn.apply(this, [message].concat(optionalParams));
        }
    };
    Logger.prototype.error = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.errfn.apply(this, [message].concat(optionalParams));
    };
    return Logger;
}());
exports.Logger = Logger;

},{}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var PromiseWithNotify = (function (_super) {
    __extends(PromiseWithNotify, _super);
    function PromiseWithNotify() {
        _super.apply(this, arguments);
    }
    PromiseWithNotify.prototype.then = function (onFulfilled, onRejected, onNotified) {
        this.onNotify = onNotified;
        return _super.prototype.then.call(this, onFulfilled, onRejected);
    };
    return PromiseWithNotify;
}(Promise));
exports.PromiseWithNotify = PromiseWithNotify;
var DeferredPromise = (function () {
    function DeferredPromise() {
        var _this = this;
        this.notifyValues = [];
        this.promise = new PromiseWithNotify(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
        var originalThen = this.promise.then;
        this.promise.then = function (ok, fail, notify) {
            _this._notify = notify;
            for (var _i = 0, _a = _this.notifyValues; _i < _a.length; _i++) {
                var v = _a[_i];
                _this._notify(v);
            }
            return originalThen.call(_this.promise, ok, fail);
        };
    }
    DeferredPromise.prototype.notify = function (value) {
        if (typeof this._notify !== 'function') {
            this.notifyValues.push(value);
        }
        else {
            this._notify(value);
        }
    };
    return DeferredPromise;
}());
exports.DeferredPromise = DeferredPromise;

},{}],18:[function(require,module,exports){
"use strict";
var promise_1 = require('./promise');
var auth_1 = require('../auth/auth');
var r = require('superagent');
function request(options) {
    options.headers = options.headers || {};
    if (!options.headers.Authorization) {
        var token = auth_1.Auth.getUserToken();
        if (token) {
            options.headers.Authorization = 'Bearer ' + token;
        }
    }
    var requestInfo = {};
    var p = new promise_1.DeferredPromise();
    var request_method = (options.method || 'get').toLowerCase();
    var req = r[request_method](options.uri || options.url);
    if (options.json) {
        req = req.send(options.json);
    }
    if (options.headers) {
        req = req.set(options.headers);
    }
    req = req.end(function (err, res) {
        requestInfo._lastError = err;
        requestInfo._lastResult = res;
        if (err) {
            p.reject(err);
        }
        else {
            if (res.status < 200 || res.status >= 400) {
                var _err = new Error('Request Failed with status code of ' + res.status);
                p.reject({ 'response': res, 'error': _err });
            }
            else {
                p.resolve({ 'response': res, 'payload': res.body });
            }
        }
    });
    p.requestInfo = requestInfo;
    return p.promise;
}
exports.request = request;

},{"../auth/auth":5,"./promise":17,"superagent":37}],19:[function(require,module,exports){
"use strict";
var promise_1 = require('./promise');
var LocalStorageStrategy = (function () {
    function LocalStorageStrategy() {
    }
    LocalStorageStrategy.prototype.get = function (key) {
        return localStorage.getItem(key);
    };
    LocalStorageStrategy.prototype.remove = function (key) {
        return localStorage.removeItem(key);
    };
    LocalStorageStrategy.prototype.set = function (key, value) {
        return localStorage.setItem(key, value);
    };
    return LocalStorageStrategy;
}());
exports.LocalStorageStrategy = LocalStorageStrategy;
var SessionStorageStrategy = (function () {
    function SessionStorageStrategy() {
    }
    SessionStorageStrategy.prototype.get = function (key) {
        return sessionStorage.getItem(key);
    };
    SessionStorageStrategy.prototype.remove = function (key) {
        return sessionStorage.removeItem(key);
    };
    SessionStorageStrategy.prototype.set = function (key, value) {
        return sessionStorage.setItem(key, value);
    };
    return SessionStorageStrategy;
}());
exports.SessionStorageStrategy = SessionStorageStrategy;
var objectCache = {};
var memoryLocks = {};
var Storage = (function () {
    function Storage() {
        this.strategy = new LocalStorageStrategy();
    }
    /**
     * Stores an object in local storage under the given key
     * @param {string} key Name of the key to store values in
     * @param {object} object The object to store with the key
     * @return {void}
     */
    Storage.prototype.storeObject = function (key, object) {
        // Convert object to JSON and store in localStorage
        var json = JSON.stringify(object);
        this.strategy.set(key, json);
        // Then store it in the object cache
        objectCache[key] = object;
    };
    Storage.prototype.deleteObject = function (key) {
        this.strategy.remove(key);
        delete objectCache[key];
    };
    /**
     * Either retrieves the cached copy of an object,
     * or the object itself from localStorage.
     * @param {string} key The name of the key to pull from
     * @return {mixed} Returns the previously stored Object or null
     */
    Storage.prototype.retrieveObject = function (key) {
        // First check to see if it's the object cache
        var cached = objectCache[key];
        if (cached) {
            return cached;
        }
        // Deserialize the object from JSON
        var json = this.strategy.get(key);
        // null or undefined --> return null.
        if (json === null) {
            return null;
        }
        try {
            return JSON.parse(json);
        }
        catch (err) {
            return null;
        }
    };
    /**
     * Locks the async call represented by the given promise and lock key.
     * Only one asyncFunction given by the lockKey can be running at any time.
     *
     * @param {string} lockKey should be a string representing the name of this async call.
     *        This is required for persistence.
     * @param {function} asyncFunction Returns a promise of the async call.
     * @returns {Promise} A new promise, identical to the one returned by asyncFunction,
     *          but with two new errors: 'in_progress', and 'last_call_interrupted'.
     */
    Storage.prototype.lockedAsyncCall = function (lockKey, asyncFunction) {
        var self = this;
        var deferred = new promise_1.DeferredPromise();
        // If the memory lock is set, error out.
        if (memoryLocks[lockKey]) {
            deferred.reject('in_progress');
            return deferred.promise;
        }
        // If there is a stored lock but no memory lock, flag a persistence error
        if (this.strategy.get(lockKey) === 'locked') {
            deferred.reject('last_call_interrupted');
            deferred.promise.then(null, function () {
                self.strategy.remove(lockKey);
            });
            return deferred.promise;
        }
        // Set stored and memory locks
        memoryLocks[lockKey] = true;
        self.strategy.set(lockKey, 'locked');
        // Perform the async operation
        asyncFunction().then(function (successData) {
            deferred.resolve(successData);
            // Remove stored and memory locks
            delete memoryLocks[lockKey];
            self.strategy.remove(lockKey);
        }, function (errorData) {
            deferred.reject(errorData);
            // Remove stored and memory locks
            delete memoryLocks[lockKey];
            self.strategy.remove(lockKey);
        }, function (notifyData) {
            deferred.notify(notifyData);
        });
        return deferred.promise;
    };
    return Storage;
}());
exports.Storage = Storage;

},{"./promise":17}],20:[function(require,module,exports){
"use strict";
var auth_1 = require('../auth/auth');
var promise_1 = require('./promise');
var core_1 = require('./core');
var storage_1 = require('./storage');
var data_types_1 = require('./data-types');
var AppUserContext = null;
var storage = new storage_1.Storage();
var UserContext = (function () {
    function UserContext() {
    }
    Object.defineProperty(UserContext, "label", {
        get: function () {
            return 'ionic_io_user_' + core_1.IonicPlatform.config.get('app_id');
        },
        enumerable: true,
        configurable: true
    });
    UserContext.delete = function () {
        storage.deleteObject(UserContext.label);
    };
    UserContext.store = function () {
        if (UserContext.getRawData()) {
            UserContext.storeLegacyData(UserContext.getRawData());
        }
        if (User.current().data.data.__ionic_user_migrated) {
            storage.storeObject(UserContext.label + '_legacy', { '__ionic_user_migrated': true });
        }
        storage.storeObject(UserContext.label, User.current());
    };
    UserContext.storeLegacyData = function (data) {
        if (!UserContext.getRawLegacyData()) {
            storage.storeObject(UserContext.label + '_legacy', data);
        }
    };
    UserContext.getRawData = function () {
        return storage.retrieveObject(UserContext.label) || false;
    };
    UserContext.getRawLegacyData = function () {
        return storage.retrieveObject(UserContext.label + '_legacy') || false;
    };
    UserContext.load = function () {
        var data = storage.retrieveObject(UserContext.label) || false;
        if (data) {
            UserContext.storeLegacyData(data);
            return User.fromContext(data);
        }
        return;
    };
    return UserContext;
}());
var UserData = (function () {
    function UserData(data) {
        if (data === void 0) { data = {}; }
        this.data = {};
        if ((typeof data === 'object')) {
            this.data = data;
            this.deserializerDataTypes();
        }
    }
    UserData.prototype.deserializerDataTypes = function () {
        for (var x in this.data) {
            // if we have an object, let's check for custom data types
            if (typeof this.data[x] === 'object') {
                // do we have a custom type?
                if (this.data[x].__Ionic_DataTypeSchema) {
                    var name = this.data[x].__Ionic_DataTypeSchema;
                    var mapping = data_types_1.DataType.getMapping();
                    if (mapping[name]) {
                        // we have a custom type and a registered class, give the custom data type
                        // from storage
                        this.data[x] = mapping[name].fromStorage(this.data[x].value);
                    }
                }
            }
        }
    };
    UserData.prototype.set = function (key, value) {
        this.data[key] = value;
    };
    UserData.prototype.unset = function (key) {
        delete this.data[key];
    };
    UserData.prototype.get = function (key, defaultValue) {
        if (this.data.hasOwnProperty(key)) {
            return this.data[key];
        }
        else {
            if (defaultValue === 0 || defaultValue === false) {
                return defaultValue;
            }
            return defaultValue || null;
        }
    };
    return UserData;
}());
exports.UserData = UserData;
var User = (function () {
    function User() {
        this._blockLoad = false;
        this._blockSave = false;
        this._blockDelete = false;
        this._dirty = false;
        this._fresh = true;
        this._unset = {};
        this.data = new UserData();
    }
    User.prototype.isDirty = function () {
        return this._dirty;
    };
    User.prototype.isAnonymous = function () {
        if (!this.id) {
            return true;
        }
        else {
            return false;
        }
    };
    User.prototype.isAuthenticated = function () {
        if (this === User.current()) {
            return auth_1.Auth.isAuthenticated();
        }
        return false;
    };
    User.current = function (user) {
        if (!AppUserContext) {
            AppUserContext = UserContext.load();
        }
        if (!AppUserContext) {
            AppUserContext = new User();
        }
        if (user) {
            AppUserContext.id = user.id;
            AppUserContext.data = user.data;
            AppUserContext.details = user.details;
            AppUserContext._fresh = user._fresh;
        }
        return AppUserContext;
    };
    User.fromContext = function (data) {
        var user = new User();
        user.id = data._id;
        user.data = new UserData(data.data.data);
        user.details = data.details || {};
        user._fresh = data._fresh;
        user._dirty = data._dirty;
        return user;
    };
    User.self = function () {
        var deferred = new promise_1.DeferredPromise();
        var tempUser = new User();
        if (!tempUser._blockLoad) {
            tempUser._blockLoad = true;
            core_1.IonicPlatform.client.get('/auth/users/self')
                .end(function (err, res) {
                if (err) {
                    tempUser._blockLoad = false;
                    core_1.IonicPlatform.logger.error('Ionic User:', err);
                    deferred.reject(err);
                }
                else {
                    tempUser._blockLoad = false;
                    core_1.IonicPlatform.logger.info('Ionic User: loaded user');
                    // set the custom data
                    tempUser.id = res.body.data.uuid;
                    tempUser.data = new UserData(res.body.data.custom);
                    tempUser.details = res.body.data.details;
                    tempUser._fresh = false;
                    User.current(tempUser);
                    deferred.resolve(User.current());
                }
            });
        }
        else {
            core_1.IonicPlatform.logger.info('Ionic User: a load operation is already in progress for ' + this + '.');
            deferred.reject(false);
        }
        return deferred.promise;
    };
    User.load = function (id) {
        var deferred = new promise_1.DeferredPromise();
        var tempUser = new User();
        tempUser.id = id;
        if (!tempUser._blockLoad) {
            tempUser._blockLoad = true;
            core_1.IonicPlatform.client.get("/auth/users/" + tempUser.id)
                .end(function (err, res) {
                if (err) {
                    tempUser._blockLoad = false;
                    core_1.IonicPlatform.logger.error('Ionic User:', err);
                    deferred.reject(err);
                }
                else {
                    tempUser._blockLoad = false;
                    core_1.IonicPlatform.logger.info('Ionic User: loaded user');
                    // set the custom data
                    tempUser.data = new UserData(res.body.data.custom);
                    tempUser.details = res.body.data.details;
                    tempUser._fresh = false;
                    deferred.resolve(tempUser);
                }
            });
        }
        else {
            core_1.IonicPlatform.logger.info('Ionic User: a load operation is already in progress for ' + this + '.');
            deferred.reject(false);
        }
        return deferred.promise;
    };
    User.prototype.clear = function () {
        return User.current(new User());
    };
    User.prototype.isFresh = function () {
        return this._fresh;
    };
    User.prototype.isValid = function () {
        if (this.id) {
            return true;
        }
        return false;
    };
    User.prototype.getAPIFormat = function () {
        var apiFormat = {};
        for (var key in this.details) {
            apiFormat[key] = this.details[key];
        }
        apiFormat.custom = this.data.data;
        return apiFormat;
    };
    User.prototype.getFormat = function (format) {
        var formatted = null;
        switch (format) {
            case 'api-save':
                formatted = this.getAPIFormat();
                break;
        }
        return formatted;
    };
    User.prototype.migrate = function () {
        var rawData = UserContext.getRawLegacyData();
        if (rawData) {
            if (!rawData.__ionic_user_migrated) {
                var currentUser = Ionic.User.current();
                var userData = new UserData(rawData.data.data);
                for (var key in userData.data) {
                    currentUser.set(key, userData.data[key]);
                }
                currentUser.set('__ionic_user_migrated', true);
            }
        }
    };
    User.prototype.delete = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        if (this.isValid()) {
            if (!this._blockDelete) {
                this._blockDelete = true;
                this._delete();
                core_1.IonicPlatform.client.delete("/auth/users/" + this.id)
                    .end(function (err, res) {
                    if (err) {
                        _this._blockDelete = false;
                        core_1.IonicPlatform.logger.error('Ionic User:', err);
                        deferred.reject(err);
                    }
                    else {
                        _this._blockDelete = false;
                        core_1.IonicPlatform.logger.info('Ionic User: deleted ' + _this);
                        deferred.resolve(res);
                    }
                });
            }
            else {
                core_1.IonicPlatform.logger.info('Ionic User: a delete operation is already in progress for ' + this + '.');
                deferred.reject(false);
            }
        }
        else {
            deferred.reject(false);
        }
        return deferred.promise;
    };
    User.prototype._store = function () {
        if (this === User.current()) {
            UserContext.store();
        }
    };
    User.prototype._delete = function () {
        if (this === User.current()) {
            UserContext.delete();
        }
    };
    User.prototype.save = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        if (!this._blockSave) {
            this._blockSave = true;
            this._store();
            core_1.IonicPlatform.client.patch("/auth/users/" + this.id)
                .send(this.getFormat('api-save'))
                .end(function (err, res) {
                if (err) {
                    _this._dirty = true;
                    _this._blockSave = false;
                    core_1.IonicPlatform.logger.error('Ionic User:', err);
                    deferred.reject(err);
                }
                else {
                    _this._dirty = false;
                    if (!_this.isFresh()) {
                        _this._unset = {};
                    }
                    _this._fresh = false;
                    _this._blockSave = false;
                    core_1.IonicPlatform.logger.info('Ionic User: saved user');
                    deferred.resolve(res);
                }
            });
        }
        else {
            core_1.IonicPlatform.logger.info('Ionic User: a save operation is already in progress for ' + this + '.');
            deferred.reject(false);
        }
        return deferred.promise;
    };
    User.prototype.resetPassword = function () {
        var deferred = new promise_1.DeferredPromise();
        core_1.IonicPlatform.client.post("/auth/users/" + this.id + "/password-reset")
            .end(function (err, res) {
            if (err) {
                core_1.IonicPlatform.logger.error('Ionic User:', err);
                deferred.reject(err);
            }
            else {
                core_1.IonicPlatform.logger.info('Ionic User: password reset for user');
                deferred.resolve(res);
            }
        });
        return deferred.promise;
    };
    Object.defineProperty(User.prototype, "id", {
        get: function () {
            return this._id || null;
        },
        set: function (v) {
            this._id = v;
        },
        enumerable: true,
        configurable: true
    });
    User.prototype.toString = function () {
        return '<IonicUser [\'' + this.id + '\']>';
    };
    User.prototype.set = function (key, value) {
        delete this._unset[key];
        return this.data.set(key, value);
    };
    User.prototype.get = function (key, defaultValue) {
        return this.data.get(key, defaultValue);
    };
    User.prototype.unset = function (key) {
        this._unset[key] = true;
        return this.data.unset(key);
    };
    return User;
}());
exports.User = User;

},{"../auth/auth":5,"./core":11,"./data-types":12,"./promise":17,"./storage":19}],21:[function(require,module,exports){
"use strict";
var promise_1 = require('../core/promise');
var core_1 = require('../core/core');
var NO_PLUGIN = 'IONIC_DEPLOY_MISSING_PLUGIN';
var INITIAL_DELAY = 1 * 5 * 1000;
var WATCH_INTERVAL = 1 * 60 * 1000;
var Deploy = (function () {
    function Deploy() {
        var self = this;
        this._plugin = false;
        this._isReady = false;
        this._channelTag = 'production';
        core_1.IonicPlatform.logger.info('Ionic Deploy: init');
        core_1.IonicPlatform.onReady(function () {
            self.initialize();
            self._isReady = true;
            core_1.IonicPlatform.emitter.emit('deploy:ready');
        });
    }
    /**
     * Fetch the Deploy Plugin
     *
     * If the plugin has not been set yet, attempt to fetch it, otherwise log
     * a message.
     *
     * @return {IonicDeploy} Returns the plugin or false
     */
    Deploy.prototype._getPlugin = function () {
        if (this._plugin) {
            return this._plugin;
        }
        if (typeof IonicDeploy === 'undefined') {
            core_1.IonicPlatform.logger.info('Ionic Deploy: plugin is not installed or has not loaded. Have you run `ionic plugin add ionic-plugin-deploy` yet?');
            return false;
        }
        this._plugin = IonicDeploy;
        return IonicDeploy;
    };
    /**
     * Initialize the Deploy Plugin
     * @return {void}
     */
    Deploy.prototype.initialize = function () {
        var self = this;
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.init(core_1.IonicPlatform.config.get('app_id'), core_1.IonicPlatform.config.getURL('platform-api'));
            }
        });
    };
    /**
     * Check for updates
     *
     * @return {Promise} Will resolve with true if an update is available, false otherwise. A string or
     *   error will be passed to reject() in the event of a failure.
     */
    Deploy.prototype.check = function () {
        var self = this;
        var deferred = new promise_1.DeferredPromise();
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.check(core_1.IonicPlatform.config.get('app_id'), self._channelTag, function (result) {
                    if (result && result === 'true') {
                        core_1.IonicPlatform.logger.info('Ionic Deploy: an update is available');
                        deferred.resolve(true);
                    }
                    else {
                        core_1.IonicPlatform.logger.info('Ionic Deploy: no updates available');
                        deferred.resolve(false);
                    }
                }, function (error) {
                    core_1.IonicPlatform.logger.error('Ionic Deploy: encountered an error while checking for updates');
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Download and available update
     *
     * This should be used in conjunction with extract()
     * @return {Promise} The promise which will resolve with true/false or use
     *    notify to update the download progress.
     */
    Deploy.prototype.download = function () {
        var self = this;
        var deferred = new promise_1.DeferredPromise();
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.download(core_1.IonicPlatform.config.get('app_id'), function (result) {
                    if (result !== 'true' && result !== 'false') {
                        deferred.notify(result);
                    }
                    else {
                        if (result === 'true') {
                            core_1.IonicPlatform.logger.info('Ionic Deploy: download complete');
                        }
                        deferred.resolve(result === 'true');
                    }
                }, function (error) {
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Extract the last downloaded update
     *
     * This should be called after a download() successfully resolves.
     * @return {Promise} The promise which will resolve with true/false or use
     *                   notify to update the extraction progress.
     */
    Deploy.prototype.extract = function () {
        var self = this;
        var deferred = new promise_1.DeferredPromise();
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.extract(core_1.IonicPlatform.config.get('app_id'), function (result) {
                    if (result !== 'done') {
                        deferred.notify(result);
                    }
                    else {
                        if (result === 'true') {
                            core_1.IonicPlatform.logger.info('Ionic Deploy: extraction complete');
                        }
                        deferred.resolve(result);
                    }
                }, function (error) {
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Load the latest deployed version
     * This is only necessary to call if you have manually downloaded and extracted
     * an update and wish to reload the app with the latest deploy. The latest deploy
     * will automatically be loaded when the app is started.
     *
     * @return {void}
     */
    Deploy.prototype.load = function () {
        var self = this;
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.redirect(core_1.IonicPlatform.config.get('app_id'));
            }
        });
    };
    /**
     * Watch constantly checks for updates, and triggers an
     * event when one is ready.
     * @param {object} options Watch configuration options
     * @return {Promise} returns a promise that will get a notify() callback when an update is available
     */
    Deploy.prototype.watch = function (options) {
        var deferred = new promise_1.DeferredPromise();
        var opts = options || {};
        var self = this;
        if (typeof opts.initialDelay === 'undefined') {
            opts.initialDelay = INITIAL_DELAY;
        }
        if (typeof opts.interval === 'undefined') {
            opts.interval = WATCH_INTERVAL;
        }
        function checkForUpdates() {
            self.check().then(function (hasUpdate) {
                if (hasUpdate) {
                    deferred.notify(hasUpdate);
                }
            }, function (err) {
                core_1.IonicPlatform.logger.info('Ionic Deploy: unable to check for updates: ' + err);
            });
            // Check our timeout to make sure it wasn't cleared while we were waiting
            // for a server response
            if (this._checkTimeout) {
                this._checkTimeout = setTimeout(checkForUpdates.bind(self), opts.interval);
            }
        }
        // Check after an initial short deplay
        this._checkTimeout = setTimeout(checkForUpdates.bind(self), opts.initialDelay);
        return deferred.promise;
    };
    /**
     * Stop automatically looking for updates
     * @return {void}
     */
    Deploy.prototype.unwatch = function () {
        clearTimeout(this._checkTimeout);
        this._checkTimeout = null;
    };
    /**
     * Information about the current deploy
     *
     * @return {Promise} The resolver will be passed an object that has key/value
     *    pairs pertaining to the currently deployed update.
     */
    Deploy.prototype.info = function () {
        var deferred = new promise_1.DeferredPromise();
        var self = this;
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.info(core_1.IonicPlatform.config.get('app_id'), function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * List the Deploy versions that have been installed on this device
     *
     * @return {Promise} The resolver will be passed an array of deploy uuids
     */
    Deploy.prototype.getVersions = function () {
        var deferred = new promise_1.DeferredPromise();
        var self = this;
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.getVersions(core_1.IonicPlatform.config.get('app_id'), function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Remove an installed deploy on this device
     *
     * @param {string} uuid The deploy uuid you wish to remove from the device
     * @return {Promise} Standard resolve/reject resolution
     */
    Deploy.prototype.deleteVersion = function (uuid) {
        var deferred = new promise_1.DeferredPromise();
        var self = this;
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.deleteVersion(core_1.IonicPlatform.config.get('app_id'), uuid, function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Fetches the metadata for a given deploy uuid. If no uuid is given, it will attempt
     * to grab the metadata for the most recently known update version.
     *
     * @param {string} uuid The deploy uuid you wish to grab metadata for, can be left blank to grab latest known update metadata
     * @return {Promise} Standard resolve/reject resolution
     */
    Deploy.prototype.getMetadata = function (uuid) {
        var deferred = new promise_1.DeferredPromise();
        var self = this;
        this.onReady(function () {
            if (self._getPlugin()) {
                self._plugin.getMetadata(core_1.IonicPlatform.config.get('app_id'), uuid, function (result) {
                    deferred.resolve(result.metadata);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Set the deploy channel that should be checked for updatse
     * See http://docs.ionic.io/docs/deploy-channels for more information
     *
     * @param {string} channelTag The channel tag to use
     * @return {void}
     */
    Deploy.prototype.setChannel = function (channelTag) {
        this._channelTag = channelTag;
    };
    /**
     * Update app with the latest deploy
     * @param {boolean} deferLoad Defer loading the applied update after the installation
     * @return {Promise} A promise result
     */
    Deploy.prototype.update = function (deferLoad) {
        var deferred = new promise_1.DeferredPromise();
        var self = this;
        var deferLoading = false;
        if (typeof deferLoad !== 'undefined') {
            deferLoading = deferLoad;
        }
        this.onReady(function () {
            if (self._getPlugin()) {
                // Check for updates
                self.check().then(function (result) {
                    if (result === true) {
                        // There are updates, download them
                        var downloadProgress = 0;
                        self.download().then(function (result) {
                            if (!result) {
                                deferred.reject('download error');
                            }
                            self.extract().then(function (result) {
                                if (!result) {
                                    deferred.reject('extraction error');
                                }
                                if (!deferLoading) {
                                    deferred.resolve(true);
                                    self._plugin.redirect(core_1.IonicPlatform.config.get('app_id'));
                                }
                                else {
                                    deferred.resolve(true);
                                }
                            }, function (error) {
                                deferred.reject(error);
                            }, function (update) {
                                var progress = downloadProgress + (update / 2);
                                deferred.notify(progress);
                            });
                        }, function (error) {
                            deferred.reject(error);
                        }, function (update) {
                            downloadProgress = (update / 2);
                            deferred.notify(downloadProgress);
                        });
                    }
                    else {
                        deferred.resolve(false);
                    }
                }, function (error) {
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Fire a callback when deploy is ready. This will fire immediately if
     * deploy has already become available.
     *
     * @param {Function} callback Callback function to fire off
     * @return {void}
     */
    Deploy.prototype.onReady = function (callback) {
        var self = this;
        if (this._isReady) {
            callback(self);
        }
        else {
            core_1.IonicPlatform.emitter.on('deploy:ready', function () {
                callback(self);
            });
        }
    };
    return Deploy;
}());
exports.Deploy = Deploy;

},{"../core/core":11,"../core/promise":17}],22:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./deploy'));

},{"./deploy":21}],23:[function(require,module,exports){
"use strict";
var core_1 = require('../core/core');
var promise_1 = require('../core/promise');
var Environment = (function () {
    /**
     * Environment constructor
     *
     * @param {object} config Configuration object
     */
    function Environment() {
    }
    /**
     * Load an environment, calls loadEnvFromAPI
     *
     * @param {string} tag Environment tag
     * @return {PromiseWithNotify} will resolve/reject with the config object or error
     */
    Environment.prototype.load = function (tag) {
        var deferred = new promise_1.DeferredPromise();
        this.loadEnvFromAPI(tag).then(function (env) {
            deferred.resolve(env['config']);
        }, function (err) {
            deferred.reject(err);
        });
        return deferred.promise;
    };
    /**
     * Load an environment from the API
     *
     * @param {string} tag Environment tag
     * @return {PromiseWithNotify} will resolve/reject with the config object or error
     */
    Environment.prototype.loadEnvFromAPI = function (tag) {
        var deferred = new promise_1.DeferredPromise();
        var appId = core_1.IonicPlatform.config.get('app_id');
        core_1.IonicPlatform.client.get("/apps/" + appId + "/env/" + tag)
            .end(function (err, res) {
            if (err) {
                deferred.reject(err);
            }
            else if (res.ok) {
                deferred.resolve(res.body.data);
            }
        });
        return deferred.promise;
    };
    return Environment;
}());
exports.Environment = Environment;

},{"../core/core":11,"../core/promise":17}],24:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./environments'));

},{"./environments":23}],25:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./analytics/index'));
__export(require('./auth/index'));
__export(require('./core/index'));
__export(require('./deploy/index'));
__export(require('./insights/index'));
__export(require('./environments/index'));
__export(require('./push/index'));
__export(require('./links/index'));
__export(require('./util/index'));

},{"./analytics/index":2,"./auth/index":6,"./core/index":15,"./deploy/index":22,"./environments/index":24,"./insights/index":26,"./links/index":28,"./push/index":30,"./util/index":35}],26:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./insights'));

},{"./insights":27}],27:[function(require,module,exports){
"use strict";
var Stat = (function () {
    function Stat(appId, stat, value) {
        if (value === void 0) { value = 1; }
        this.appId = appId;
        this.stat = stat;
        this.value = value;
        this.appId = appId;
        this.stat = stat;
        this.value = value;
        this.created = new Date();
    }
    Stat.prototype.toJSON = function () {
        return {
            app_id: this.appId,
            stat: this.stat,
            value: this.value,
            created: this.created.toISOString(),
        };
    };
    return Stat;
}());
exports.Stat = Stat;
var Insights = (function () {
    function Insights(client, appId) {
        this.client = client;
        this.appId = appId;
        this.submitCount = Insights.SUBMIT_COUNT;
        this.client = client;
        this.appId = appId;
        this.batch = [];
    }
    Insights.prototype.track = function (stat, value) {
        if (value === void 0) { value = 1; }
        this.trackStat(new Stat(this.appId, stat, value));
    };
    Insights.prototype.trackStat = function (stat) {
        this.batch.push(stat);
        if (this.shouldSubmit()) {
            this.submit();
        }
    };
    Insights.prototype.shouldSubmit = function () {
        return this.batch.length >= this.submitCount;
    };
    Insights.prototype.submit = function () {
        var insights = [];
        for (var _i = 0, _a = this.batch; _i < _a.length; _i++) {
            var stat = _a[_i];
            insights.push(stat.toJSON());
        }
        return this.client.post('/insights')
            .send({ 'insights': insights });
    };
    Insights.SUBMIT_COUNT = 100;
    return Insights;
}());
exports.Insights = Insights;

},{}],28:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./links'));

},{"./links":29}],29:[function(require,module,exports){
"use strict";
var Links = (function () {
    function Links(client, appId) {
        this.client = client;
        this.appId = appId;
        this.client = client;
        this.appId = appId;
    }
    Links.prototype.start = function () {
    };
    return Links;
}());
exports.Links = Links;

},{}],30:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./push-dev'));
__export(require('./push-message'));
__export(require('./push-token'));
__export(require('./push'));

},{"./push":34,"./push-dev":31,"./push-message":32,"./push-token":33}],31:[function(require,module,exports){
"use strict";
var core_1 = require('../core/core');
var util_1 = require('../util/util');
var push_token_1 = require('./push-token');
/**
 * PushDev Service
 *
 * This service acts as a mock push service that is intended to be used pre-setup of
 * GCM/APNS in an Ionic.io project.
 *
 * How it works:
 *
 *   When register() is called, this service is used to generate a random
 *   development device token. This token is not valid for any service outside of
 *   Ionic Push with `dev_push` set to true. These tokens do not last long and are not
 *   eligible for use in a production app.
 *
 *   The device will then periodically check the Push service for push notifications sent
 *   to our development token -- so unlike a typical "push" update, this actually uses
 *   "polling" to find new notifications. This means you *MUST* have the application open
 *   and in the foreground to retreive messsages.
 *
 *   The callbacks provided in your init() will still be triggered as normal,
 *   but with these notable exceptions:
 *
 *      - There is no payload data available with messages
 *      - An alert() is called when a notification is received unlesss you return false
 *        in your 'onNotification' callback.
 *
 */
var PushDevService = (function () {
    function PushDevService() {
        this.client = core_1.IonicPlatform.client;
        this._token = null;
        this._watch = null;
    }
    /**
     * Generate a development token
     *
     * @return {String} development device token
     */
    PushDevService.prototype.getDevToken = function () {
        var token = util_1.generateUUID();
        this._token = 'DEV-' + token;
        return this._token;
    };
    /**
     * Registers a development token with the Ionic Push service
     *
     * @param {IonicPushService} ionicPush Instantiated Push Service
     * @param {function} callback Registration Callback
     * @return {void}
     */
    PushDevService.prototype.init = function (ionicPush, callback) {
        var _this = this;
        this._push = ionicPush;
        var token = this._token;
        if (!token) {
            token = this.getDevToken();
        }
        this.client.post('/push/development')
            .send({ 'token': token })
            .end(function (err, res) {
            if (err) {
                core_1.IonicPlatform.logger.error('Ionic Push (dev): error connecting development push service: ' + err);
            }
            else {
                var data = { 'registrationId': token };
                core_1.IonicPlatform.logger.info('Ionic Push (dev): registered with development push service: ' + token);
                core_1.IonicPlatform.emitter.emit('push:token', data);
                if (typeof callback === 'function') {
                    callback(new push_token_1.PushToken(_this._token));
                }
                _this.watch();
            }
        });
    };
    /**
     * Checks the push service for notifications that target the current development token
     * @return {void}
     */
    PushDevService.prototype.checkForNotifications = function () {
        if (!this._token) {
            return;
        }
        this.client.get('/push/development')
            .query({ 'token': this._token })
            .end(function (err, res) {
            if (err) {
                core_1.IonicPlatform.logger.error('Ionic Push (dev): unable to check for development pushes: ' + err);
            }
            else {
                if (res.body.data.message) {
                    var message = {
                        'message': res.body.data.message,
                        'title': 'DEVELOPMENT PUSH'
                    };
                    core_1.IonicPlatform.logger.warn('Ionic Push (dev): Development Push received. Development pushes will not contain payload data.');
                    core_1.IonicPlatform.emitter.emit('push:notification', message);
                }
            }
        });
    };
    /**
     * Kicks off the "polling" of the Ionic Push service for new push notifications
     * @return {void}
     */
    PushDevService.prototype.watch = function () {
        // Check for new dev pushes every 5 seconds
        core_1.IonicPlatform.logger.info('Ionic Push (dev): watching for new notifications');
        var self = this;
        if (!this._watch) {
            this._watch = setInterval(function () { self.checkForNotifications(); }, 5000);
        }
    };
    /**
     * Puts the "polling" for new notifications on hold.
     * @return {void}
     */
    PushDevService.prototype.halt = function () {
        if (this._watch) {
            clearInterval(this._watch);
        }
    };
    return PushDevService;
}());
exports.PushDevService = PushDevService;

},{"../core/core":11,"../util/util":36,"./push-token":33}],32:[function(require,module,exports){
"use strict";
var PushMessage = (function () {
    function PushMessage(raw) {
        this.app = {};
        this._raw = raw || {};
        if (!this._raw.additionalData) {
            // this should only hit if we are serving up a development push
            this._raw.additionalData = {
                'coldstart': false,
                'foreground': true
            };
        }
        this._payload = null;
        this.text = null;
        this.title = null;
        this.count = null;
        this.sound = null;
        this.image = null;
    }
    PushMessage.fromPluginJSON = function (json) {
        var message = new PushMessage(json);
        message.processRaw();
        return message;
    };
    Object.defineProperty(PushMessage.prototype, "payload", {
        get: function () {
            return this._payload || {};
        },
        enumerable: true,
        configurable: true
    });
    PushMessage.prototype.processRaw = function () {
        this.text = this._raw.message || null;
        this.title = this._raw.title || null;
        this.count = this._raw.count || null;
        this.sound = this._raw.sound || null;
        this.image = this._raw.image || null;
        if (!this._raw.additionalData.foreground) {
            this.app.asleep = true;
        }
        if (this._raw.additionalData.coldstart) {
            this.app.closed = true;
        }
        if (this._raw.additionalData.payload) {
            this._payload = this._raw.additionalData.payload;
        }
    };
    PushMessage.prototype.getRawVersion = function () {
        return this._raw;
    };
    PushMessage.prototype.toString = function () {
        return '<PushMessage [\'' + this.title + '\']>';
    };
    return PushMessage;
}());
exports.PushMessage = PushMessage;

},{}],33:[function(require,module,exports){
"use strict";
var PushToken = (function () {
    function PushToken(token) {
        this.token = token;
        this.token = token;
    }
    PushToken.prototype.toString = function () {
        return "<PushToken [" + this.token + "]>";
    };
    return PushToken;
}());
exports.PushToken = PushToken;

},{}],34:[function(require,module,exports){
"use strict";
var app_1 = require('../core/app');
var core_1 = require('../core/core');
var promise_1 = require('../core/promise');
var user_1 = require('../core/user');
var push_token_1 = require('./push-token');
var push_message_1 = require('./push-message');
var push_dev_1 = require('./push-dev');
var Push = (function () {
    function Push(config) {
        var _this = this;
        if (config === void 0) { config = {}; }
        this._token = null;
        this.client = core_1.IonicPlatform.client;
        var app = new app_1.App(core_1.IonicPlatform.config.get('app_id'), core_1.IonicPlatform.config.get('api_key'));
        app.devPush = core_1.IonicPlatform.config.get('dev_push');
        app.gcmKey = core_1.IonicPlatform.config.get('gcm_key');
        // Check for the required values to use this service
        if (!app.id || !app.apiKey) {
            core_1.IonicPlatform.logger.error('Ionic Push: no app_id or api_key found. (http://docs.ionic.io/docs/io-install)');
            return;
        }
        else if (core_1.IonicPlatform.device.isAndroid() && !app.devPush && !app.gcmKey) {
            core_1.IonicPlatform.logger.error('Ionic Push: GCM project number not found (http://docs.ionic.io/docs/push-android-setup)');
            return;
        }
        this.app = app;
        this.registerCallback = null;
        this.notificationCallback = null;
        this.errorCallback = null;
        this._notification = false;
        this._debug = false;
        this._isReady = false;
        this._tokenReady = false;
        this._blockRegistration = false;
        this._blockSaveToken = false;
        this._registered = false;
        this._plugin = null;
        if (!config.deferInit) {
            core_1.IonicPlatform.onReady(function () {
                _this.init(config);
            });
        }
    }
    Object.defineProperty(Push.prototype, "token", {
        set: function (val) {
            var storage = core_1.IonicPlatform.storage;
            if (val instanceof push_token_1.PushToken) {
                storage.storeObject('ionic_io_push_token', { 'token': val.token });
            }
            this._token = val;
        },
        enumerable: true,
        configurable: true
    });
    Push.prototype.getStorageToken = function () {
        var storage = core_1.IonicPlatform.storage;
        var token = storage.retrieveObject('ionic_io_push_token');
        if (token) {
            return new push_token_1.PushToken(token.token);
        }
        return null;
    };
    Push.prototype.clearStorageToken = function () {
        var storage = core_1.IonicPlatform.storage;
        storage.deleteObject('ionic_io_push_token');
    };
    /**
     * Init method to setup push behavior/options
     *
     * The config supports the following properties:
     *   - debug {Boolean} Enables some extra logging as well as some default callback handlers
     *   - onNotification {Function} Callback function that is passed the notification object
     *   - onRegister {Function} Callback function that is passed the registration object
     *   - onError {Function} Callback function that is passed the error object
     *   - pluginConfig {Object} Plugin configuration: https://github.com/phonegap/phonegap-plugin-push
     *
     * @param {object} config Configuration object
     * @return {Push} returns the called Push instantiation
     */
    Push.prototype.init = function (config) {
        if (config === void 0) { config = {}; }
        this._getPushPlugin();
        if (!config.pluginConfig) {
            config.pluginConfig = {};
        }
        if (core_1.IonicPlatform.device.isAndroid()) {
            // inject gcm key for PushPlugin
            if (!config.pluginConfig.android) {
                config.pluginConfig.android = {};
            }
            if (!config.pluginConfig.android.senderId) {
                config.pluginConfig.android.senderID = this.app.gcmKey;
            }
        }
        // Store Callbacks
        if (config.onRegister) {
            this.setRegisterCallback(config.onRegister);
        }
        if (config.onNotification) {
            this.setNotificationCallback(config.onNotification);
        }
        if (config.onError) {
            this.setErrorCallback(config.onError);
        }
        this._config = config;
        this._isReady = true;
        core_1.IonicPlatform.emitter.emit('push:ready', { 'config': this._config });
        return this;
    };
    Push.prototype.saveToken = function (token, options) {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        var opts = options || {};
        if (token.token) {
            token = token.token;
        }
        var tokenData = {
            'token': token,
            'app_id': core_1.IonicPlatform.config.get('app_id')
        };
        if (!opts.ignore_user) {
            var user = user_1.User.current();
            if (user.isAuthenticated()) {
                tokenData.user_id = user.id;
            }
        }
        if (!this._blockSaveToken) {
            this.client.post('/push/tokens')
                .send(tokenData)
                .end(function (err, res) {
                if (err) {
                    _this._blockSaveToken = false;
                    core_1.IonicPlatform.logger.error('Ionic Push:', err);
                    deferred.reject(err);
                }
                else {
                    _this._blockSaveToken = false;
                    core_1.IonicPlatform.logger.info('Ionic Push: saved push token: ' + token);
                    if (tokenData.user_id) {
                        core_1.IonicPlatform.logger.info('Ionic Push: added push token to user: ' + tokenData.user_id);
                    }
                    deferred.resolve(true);
                }
            });
        }
        else {
            core_1.IonicPlatform.logger.info('Ionic Push: a token save operation is already in progress.');
            deferred.reject(false);
        }
        return deferred.promise;
    };
    /**
     * Registers the device with GCM/APNS to get a device token
     * Fires off the 'onRegister' callback if one has been provided in the init() config
     * @param {function} callback Callback Function
     * @return {void}
     */
    Push.prototype.register = function (callback) {
        core_1.IonicPlatform.logger.info('Ionic Push: register');
        var self = this;
        if (this._blockRegistration) {
            core_1.IonicPlatform.logger.info('Ionic Push: another registration is already in progress.');
            return;
        }
        this._blockRegistration = true;
        this.onReady(function () {
            if (self.app.devPush) {
                var IonicDevPush = new push_dev_1.PushDevService();
                self._debugCallbackRegistration();
                self._callbackRegistration();
                IonicDevPush.init(self, callback);
                self._blockRegistration = false;
                self._tokenReady = true;
            }
            else {
                self._plugin = self._getPushPlugin().init(self._config.pluginConfig);
                self._plugin.on('registration', function (data) {
                    self._blockRegistration = false;
                    self.token = new push_token_1.PushToken(data.registrationId);
                    self._tokenReady = true;
                    if ((typeof callback === 'function')) {
                        callback(self._token);
                    }
                });
                self._debugCallbackRegistration();
                self._callbackRegistration();
            }
            self._registered = true;
        });
    };
    /**
     * Invalidate the current GCM/APNS token
     */
    Push.prototype.unregister = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        var platform = null;
        if (core_1.IonicPlatform.device.isAndroid()) {
            platform = 'android';
        }
        else if (core_1.IonicPlatform.device.isIOS()) {
            platform = 'ios';
        }
        if (!platform) {
            deferred.reject('Could not detect the platform, are you on a device?');
        }
        if (!this._blockUnregister) {
            if (this._plugin) {
                this._plugin.unregister(function () { }, function () { });
            }
            this.client.post('/push/tokens/invalidate')
                .send({
                'platform': platform,
                'token': this.getStorageToken().token
            })
                .end(function (err, res) {
                if (err) {
                    _this._blockUnregister = false;
                    core_1.IonicPlatform.logger.error('Ionic Push:', err);
                    deferred.reject(err);
                }
                else {
                    _this._blockUnregister = false;
                    core_1.IonicPlatform.logger.info('Ionic Push: unregistered push token: ' + _this.getStorageToken().token);
                    _this.clearStorageToken();
                    deferred.resolve(res);
                }
            });
        }
        else {
            core_1.IonicPlatform.logger.info('Ionic Push: an unregister operation is already in progress.');
            deferred.reject(false);
        }
        return deferred.promise;
    };
    /**
     * Convenience method to grab the payload object from a notification
     *
     * @param {PushNotification} notification Push Notification object
     * @return {object} Payload object or an empty object
     */
    Push.prototype.getPayload = function (notification) {
        return notification.payload;
    };
    /**
     * Set the registration callback
     *
     * @param {function} callback Registration callback function
     * @return {boolean} true if set correctly, otherwise false
     */
    Push.prototype.setRegisterCallback = function (callback) {
        if (typeof callback !== 'function') {
            core_1.IonicPlatform.logger.info('Ionic Push: setRegisterCallback() requires a valid callback function');
            return false;
        }
        this.registerCallback = callback;
        return true;
    };
    /**
     * Set the notification callback
     *
     * @param {function} callback Notification callback function
     * @return {boolean} true if set correctly, otherwise false
     */
    Push.prototype.setNotificationCallback = function (callback) {
        if (typeof callback !== 'function') {
            core_1.IonicPlatform.logger.info('Ionic Push: setNotificationCallback() requires a valid callback function');
            return false;
        }
        this.notificationCallback = callback;
        return true;
    };
    /**
     * Set the error callback
     *
     * @param {function} callback Error callback function
     * @return {boolean} true if set correctly, otherwise false
     */
    Push.prototype.setErrorCallback = function (callback) {
        if (typeof callback !== 'function') {
            core_1.IonicPlatform.logger.info('Ionic Push: setErrorCallback() requires a valid callback function');
            return false;
        }
        this.errorCallback = callback;
        return true;
    };
    Push.prototype._debugRegistrationCallback = function () {
        var self = this;
        function callback(data) {
            self.token = new push_token_1.PushToken(data.registrationId);
            core_1.IonicPlatform.logger.info('Ionic Push: (debug) device token registered: ' + self._token);
        }
        return callback;
    };
    Push.prototype._debugNotificationCallback = function () {
        var self = this;
        function callback(notification) {
            self._processNotification(notification);
            var message = push_message_1.PushMessage.fromPluginJSON(notification);
            core_1.IonicPlatform.logger.info('Ionic Push: (debug) notification received: ' + message);
            if (!self.notificationCallback && self.app.devPush) {
                alert(message.text);
            }
        }
        return callback;
    };
    Push.prototype._debugErrorCallback = function () {
        function callback(err) {
            core_1.IonicPlatform.logger.error('Ionic Push: (debug) unexpected error occured.');
            core_1.IonicPlatform.logger.error('Ionic Push:', err);
        }
        return callback;
    };
    Push.prototype._registerCallback = function () {
        var self = this;
        function callback(data) {
            self.token = new push_token_1.PushToken(data.registrationId);
            if (self.registerCallback) {
                return self.registerCallback(self._token);
            }
        }
        return callback;
    };
    Push.prototype._notificationCallback = function () {
        var self = this;
        function callback(notification) {
            self._processNotification(notification);
            var message = push_message_1.PushMessage.fromPluginJSON(notification);
            if (self.notificationCallback) {
                return self.notificationCallback(message);
            }
        }
        return callback;
    };
    Push.prototype._errorCallback = function () {
        var self = this;
        function callback(err) {
            if (self.errorCallback) {
                return self.errorCallback(err);
            }
        }
        return callback;
    };
    /**
     * Registers the default debug callbacks with the PushPlugin when debug is enabled
     * Internal Method
     * @private
     * @return {void}
     */
    Push.prototype._debugCallbackRegistration = function () {
        if (this._config.debug) {
            if (!this.app.devPush) {
                this._plugin.on('registration', this._debugRegistrationCallback());
                this._plugin.on('notification', this._debugNotificationCallback());
                this._plugin.on('error', this._debugErrorCallback());
            }
            else {
                if (!this._registered) {
                    core_1.IonicPlatform.emitter.on('push:token', this._debugRegistrationCallback());
                    core_1.IonicPlatform.emitter.on('push:notification', this._debugNotificationCallback());
                    core_1.IonicPlatform.emitter.on('push:error', this._debugErrorCallback());
                }
            }
        }
    };
    /**
     * Registers the user supplied callbacks with the PushPlugin
     * Internal Method
     * @return {void}
     */
    Push.prototype._callbackRegistration = function () {
        if (!this.app.devPush) {
            this._plugin.on('registration', this._registerCallback());
            this._plugin.on('notification', this._notificationCallback());
            this._plugin.on('error', this._errorCallback());
        }
        else {
            if (!this._registered) {
                core_1.IonicPlatform.emitter.on('push:token', this._registerCallback());
                core_1.IonicPlatform.emitter.on('push:notification', this._notificationCallback());
                core_1.IonicPlatform.emitter.on('push:error', this._errorCallback());
            }
        }
    };
    /**
     * Performs misc features based on the contents of a push notification
     * Internal Method
     *
     * Currently just does the payload $state redirection
     * @param {PushNotification} notification Push Notification object
     * @return {void}
     */
    Push.prototype._processNotification = function (notification) {
        this._notification = notification;
        core_1.IonicPlatform.emitter.emit('push:processNotification', notification);
    };
    /* Deprecated in favor of `getPushPlugin` */
    Push.prototype._getPushPlugin = function () {
        var PushPlugin = null;
        try {
            PushPlugin = window.PushNotification;
        }
        catch (e) {
            core_1.IonicPlatform.logger.info('Ionic Push: something went wrong looking for the PushNotification plugin');
        }
        if (!this.app.devPush && !PushPlugin && (core_1.IonicPlatform.device.isIOS() || core_1.IonicPlatform.device.isAndroid())) {
            core_1.IonicPlatform.logger.error('Ionic Push: PushNotification plugin is required. Have you run `ionic plugin add phonegap-plugin-push` ?');
        }
        return PushPlugin;
    };
    /**
     * Fetch the phonegap-push-plugin interface
     *
     * @return {PushNotification} PushNotification instance
     */
    Push.prototype.getPushPlugin = function () {
        return this._plugin;
    };
    /**
     * Fire a callback when Push is ready. This will fire immediately if
     * the service has already initialized.
     *
     * @param {function} callback Callback function to fire off
     * @return {void}
     */
    Push.prototype.onReady = function (callback) {
        var self = this;
        if (this._isReady) {
            callback(self);
        }
        else {
            core_1.IonicPlatform.emitter.on('push:ready', function () {
                callback(self);
            });
        }
    };
    return Push;
}());
exports.Push = Push;

},{"../core/app":7,"../core/core":11,"../core/promise":17,"../core/user":20,"./push-dev":31,"./push-message":32,"./push-token":33}],35:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./util'));

},{"./util":36}],36:[function(require,module,exports){
"use strict";
function deepExtend() {
    var out = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        out[_i - 0] = arguments[_i];
    }
    out = out[0] || {};
    for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        if (!obj) {
            continue;
        }
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (typeof obj[key] === 'object') {
                    out[key] = deepExtend(out[key], obj[key]);
                }
                else {
                    out[key] = obj[key];
                }
            }
        }
    }
    return out;
}
exports.deepExtend = deepExtend;
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
exports.generateUUID = generateUUID;

},{}],37:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  root = this;
}

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pushEncodedKeyValuePair(pairs, key, obj[key]);
        }
      }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (Array.isArray(val)) {
    return val.forEach(function(v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  }
  pairs.push(encodeURIComponent(key)
    + '=' + encodeURIComponent(val));
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    if (err) {
      return self.callback(err, res);
    }

    if (res.status >= 200 && res.status < 300) {
      return self.callback(err, res);
    }

    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
    new_err.original = err;
    new_err.response = res;
    new_err.status = res.status;

    self.callback(new_err, res);
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and 
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || isHost(data)) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * @deprecated
 */
Response.prototype.parse = function serialize(fn){
  if (root.console) {
    console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
  }
  this.serialize(fn);
  return this;
};

Response.prototype.serialize = function serialize(fn){
  this._parser = fn;
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self.timeoutError();
      if (self.aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":38,"./request":40,"./request-base":39,"emitter":41,"reduce":42}],38:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null != obj && 'object' == typeof obj;
}

module.exports = isObject;

},{}],39:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Force given parser
 *
 * Sets the body parser no matter type.
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Faux promise support
 *
 * @param {Function} fulfill
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(fulfill, reject) {
  return this.end(function(err, res) {
    err ? reject(err) : fulfill(res);
  });
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

},{"./is-object":38}],40:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],41:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],42:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],43:[function(require,module,exports){
// Add Angular integrations if Angular is available
if ((typeof angular === 'object') && angular.module) {

  var IonicAngularAnalytics = null;

  angular.module('ionic.service.analytics', ['ionic'])

  .value('IONIC_ANALYTICS_VERSION', Ionic.Analytics.version)

  .factory('$ionicAnalytics', [function() {
    if (!IonicAngularAnalytics) {
      IonicAngularAnalytics = new Ionic.Analytics("DEFER_REGISTER");
    }
    return IonicAngularAnalytics;
  }])

  .factory('domSerializer', [function() {
    return new Ionic.AnalyticSerializers.DOMSerializer();
  }])

  .run(['$ionicAnalytics', '$state', function($ionicAnalytics, $state) {
    $ionicAnalytics.setGlobalProperties(function(eventCollection, eventData) {
      if (!eventData._ui) {
        eventData._ui = {};
      }
      eventData._ui.active_state = $state.current.name; // eslint-disable-line
    });
  }]);


  angular.module('ionic.service.analytics')

  .provider('$ionicAutoTrack',[function() {

    var trackersDisabled = {},
      allTrackersDisabled = false;

    this.disableTracking = function(tracker) {
      if (tracker) {
        trackersDisabled[tracker] = true;
      } else {
        allTrackersDisabled = true;
      }
    };

    this.$get = [function() {
      return {
        "isEnabled": function(tracker) {
          return !allTrackersDisabled && !trackersDisabled[tracker];
        }
      };
    }];
  }])


  // ================================================================================
  // Auto trackers
  // ================================================================================


  .run(['$ionicAutoTrack', '$ionicAnalytics', function($ionicAutoTrack, $ionicAnalytics) {
    if (!$ionicAutoTrack.isEnabled('Load')) {
      return;
    }
    $ionicAnalytics.track('Load');
  }])

  .run([
    '$ionicAutoTrack',
    '$document',
    '$ionicAnalytics',
    'domSerializer',
    function($ionicAutoTrack, $document, $ionicAnalytics, domSerializer) {
      if (!$ionicAutoTrack.isEnabled('Tap')) {
        return;
      }

      $document.on('click', function(event) {
        // want coordinates as a percentage relative to the target element
        var box = event.target.getBoundingClientRect(),
          width = box.right - box.left,
          height = box.bottom - box.top,
          normX = (event.pageX - box.left) / width,
          normY = (event.pageY - box.top) / height;

        var eventData = {
          "coordinates": {
            "x": event.pageX,
            "y": event.pageY
          },
          "target": domSerializer.elementSelector(event.target),
          "target_identifier": domSerializer.elementName(event.target)
        };

        if (isFinite(normX) && isFinite(normY)) {
          eventData.coordinates.x_norm = normX; // eslint-disable-line
          eventData.coordinates.y_norm = normY; // eslint-disable-line
        }

        $ionicAnalytics.track('Tap', {
          "_ui": eventData
        });

      });
    }
  ])

  .run([
    '$ionicAutoTrack',
    '$ionicAnalytics',
    '$rootScope',
    function($ionicAutoTrack, $ionicAnalytics, $rootScope) {
      if (!$ionicAutoTrack.isEnabled('State Change')) {
        return;
      }

      $rootScope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) { // eslint-disable-line
        $ionicAnalytics.track('State Change', {
          "from": fromState.name,
          "to": toState.name
        });
      });
    }
  ])

  // ================================================================================
  // ion-track-$EVENT
  // ================================================================================

  /**
   * @ngdoc directive
   * @name ionTrackClick
   * @module ionic.service.analytics
   * @restrict A
   * @parent ionic.directive:ionTrackClick
   *
   * @description
   *
   * A convenient directive to automatically track a click/tap on a button
   * or other tappable element.
   *
   * @usage
   * ```html
   * <button class="button button-clear" ion-track-click ion-track-event="cta-tap">Try now!</button>
   * ```
   */

  .directive('ionTrackClick', ionTrackDirective('click'))
  .directive('ionTrackTap', ionTrackDirective('tap'))
  .directive('ionTrackDoubletap', ionTrackDirective('doubletap'))
  .directive('ionTrackHold', ionTrackDirective('hold'))
  .directive('ionTrackRelease', ionTrackDirective('release'))
  .directive('ionTrackDrag', ionTrackDirective('drag'))
  .directive('ionTrackDragLeft', ionTrackDirective('dragleft'))
  .directive('ionTrackDragRight', ionTrackDirective('dragright'))
  .directive('ionTrackDragUp', ionTrackDirective('dragup'))
  .directive('ionTrackDragDown', ionTrackDirective('dragdown'))
  .directive('ionTrackSwipeLeft', ionTrackDirective('swipeleft'))
  .directive('ionTrackSwipeRight', ionTrackDirective('swiperight'))
  .directive('ionTrackSwipeUp', ionTrackDirective('swipeup'))
  .directive('ionTrackSwipeDown', ionTrackDirective('swipedown'))
  .directive('ionTrackTransform', ionTrackDirective('hold'))
  .directive('ionTrackPinch', ionTrackDirective('pinch'))
  .directive('ionTrackPinchIn', ionTrackDirective('pinchin'))
  .directive('ionTrackPinchOut', ionTrackDirective('pinchout'))
  .directive('ionTrackRotate', ionTrackDirective('rotate'));

  /**
   * Generic directive to create auto event handling analytics directives like:
   *
   * <button ion-track-click="eventName">Click Track</button>
   * <button ion-track-hold="eventName">Hold Track</button>
   * <button ion-track-tap="eventName">Tap Track</button>
   * <button ion-track-doubletap="eventName">Double Tap Track</button>
   *
   * @param {string} domEventName The DOM event name
   * @return {array} Angular Directive declaration
   */
  function ionTrackDirective(domEventName) { // eslint-disable-line
    return ['$ionicAnalytics', '$ionicGesture', function($ionicAnalytics, $ionicGesture) {

      var gestureDriven = [
        'drag', 'dragstart', 'dragend', 'dragleft', 'dragright', 'dragup', 'dragdown',
        'swipe', 'swipeleft', 'swiperight', 'swipeup', 'swipedown',
        'tap', 'doubletap', 'hold',
        'transform', 'pinch', 'pinchin', 'pinchout', 'rotate'
      ];
      // Check if we need to use the gesture subsystem or the DOM system
      var isGestureDriven = false;
      for (var i = 0; i < gestureDriven.length; i++) {
        if (gestureDriven[i] === domEventName.toLowerCase()) {
          isGestureDriven = true;
        }
      }
      return {
        "restrict": 'A',
        "link": function($scope, $element, $attr) {
          var capitalized = domEventName[0].toUpperCase() + domEventName.slice(1);
          // Grab event name we will send
          var eventName = $attr['ionTrack' + capitalized];

          if (isGestureDriven) {
            var gesture = $ionicGesture.on(domEventName, handler, $element);
            $scope.$on('$destroy', function() {
              $ionicGesture.off(gesture, domEventName, handler);
            });
          } else {
            $element.on(domEventName, handler);
            $scope.$on('$destroy', function() {
              $element.off(domEventName, handler);
            });
          }


          function handler(e) {
            var eventData = $scope.$eval($attr.ionTrackData) || {};
            if (eventName) {
              $ionicAnalytics.track(eventName, eventData);
            } else {
              $ionicAnalytics.trackClick(e.pageX, e.pageY, e.target, {
                "data": eventData
              });
            }
          }
        }
      };
    }];
  }

}

},{}],44:[function(require,module,exports){
// Add Angular integrations if Angular is available
if ((typeof angular === 'object') && angular.module) {

  var IonicAngularAuth = null;

  angular.module('ionic.service.auth', [])

  .factory('$ionicAuth', [function() {
    if (!IonicAngularAuth) {
      IonicAngularAuth = Ionic.Auth;
    }
    return IonicAngularAuth;
  }]);
}

},{}],45:[function(require,module,exports){
// Add Angular integrations if Angular is available
if ((typeof angular === 'object') && angular.module) {
  angular.module('ionic.service.core', [])

  /**
   * @private
   * Provides a safe interface to store objects in persistent memory
   */
  .provider('persistentStorage', function() {
    return {
      '$get': [function() {
        var storage = Ionic.getService('Storage');
        if (!storage) {
          storage = new Ionic.IO.Storage();
          Ionic.addService('Storage', storage, true);
        }
        return storage;
      }]
    };
  })

  .factory('$ionicCore', [
    function() {
      return Ionic.Core;
    }
  ])

  .factory('$ionicCoreSettings', [
    function() {
      return Ionic.IO.Config;
    }
  ])

  .factory('$ionicUser', [
    function() {
      return Ionic.User;
    }
  ])

  .run([function() {
    Ionic.io();
  }]);
}


},{}],46:[function(require,module,exports){
// Add Angular integrations if Angular is available
if ((typeof angular === 'object') && angular.module) {

  var IonicAngularDeploy = null;

  angular.module('ionic.service.deploy', [])

  .factory('$ionicDeploy', [function() {
    if (!IonicAngularDeploy) {
      IonicAngularDeploy = new Ionic.Deploy();
    }
    return IonicAngularDeploy;
  }]);
}

},{}],47:[function(require,module,exports){
var Analytics = require("./../dist/es5/analytics/analytics").Analytics;
var App = require("./../dist/es5/core/app").App;
var Auth = require("./../dist/es5/auth/auth").Auth;
var BucketStorage = require("./../dist/es5/analytics/storage").BucketStorage;
var config = require("./../dist/es5/core/config").config;
var DOMSerializer = require("./../dist/es5/analytics/serializers").DOMSerializer;
var DataType = require("./../dist/es5/core/data-types").DataType;
var Deploy = require("./../dist/es5/deploy/deploy").Deploy;
var EventEmitter = require("./../dist/es5/core/events").EventEmitter;
var IonicPlatform = require("./../dist/es5/core/core").IonicPlatform;
var Logger = require("./../dist/es5/core/logger").Logger;
var Push = require("./../dist/es5/push/push").Push;
var PushMessage = require("./../dist/es5/push/push-message").PushMessage;
var PushToken = require("./../dist/es5/push/push-token").PushToken;
var Storage = require("./../dist/es5/core/storage").Storage;
var User = require("./../dist/es5/core/user").User;
var promise = require("./../dist/es5/core/promise");

// Declare the window object
window.Ionic = window.Ionic || {};

// Ionic Modules
Ionic.Core = IonicPlatform;
Ionic.User = User;
Ionic.Analytics = Analytics;
Ionic.Auth = Auth;
Ionic.Deploy = Deploy;
Ionic.Push = Push;
Ionic.PushToken = PushToken;
Ionic.PushMessage = PushMessage;

// DataType Namespace
Ionic.DataType = DataType;
Ionic.DataTypes = DataType.getMapping();

// IO Namespace
Ionic.IO = {};
Ionic.IO.App = App;
Ionic.IO.EventEmitter = EventEmitter;
Ionic.IO.Logger = Logger;
Ionic.IO.Promise = promise.Promise;
Ionic.IO.DeferredPromise = promise.DeferredPromise;
Ionic.IO.Storage = Storage;
Ionic.IO.Config = config;
Ionic.IO.Settings = function() { return config; };

// Analytic Storage Namespace
Ionic.AnalyticStorage = {};
Ionic.AnalyticStorage.BucketStorage = BucketStorage;

// Analytic Serializers Namespace
Ionic.AnalyticSerializers = {};
Ionic.AnalyticSerializers.DOMSerializer = DOMSerializer;


// Provider a single storage for services that have previously been registered
var serviceStorage = {};

Ionic.io = function() {
  return Ionic.Core;
};

Ionic.getService = function(name) {
  if (typeof serviceStorage[name] === 'undefined' || !serviceStorage[name]) {
    return false;
  }
  return serviceStorage[name];
};

Ionic.addService = function(name, service, force) {
  if (service && typeof serviceStorage[name] === 'undefined') {
    serviceStorage[name] = service;
  } else if (service && force) {
    serviceStorage[name] = service;
  }
};

Ionic.removeService = function(name) {
  if (typeof serviceStorage[name] !== 'undefined') {
    delete serviceStorage[name];
  }
};

},{"./../dist/es5/analytics/analytics":1,"./../dist/es5/analytics/serializers":3,"./../dist/es5/analytics/storage":4,"./../dist/es5/auth/auth":5,"./../dist/es5/core/app":7,"./../dist/es5/core/config":9,"./../dist/es5/core/core":11,"./../dist/es5/core/data-types":12,"./../dist/es5/core/events":14,"./../dist/es5/core/logger":16,"./../dist/es5/core/promise":17,"./../dist/es5/core/storage":19,"./../dist/es5/core/user":20,"./../dist/es5/deploy/deploy":21,"./../dist/es5/push/push":34,"./../dist/es5/push/push-message":32,"./../dist/es5/push/push-token":33}],48:[function(require,module,exports){
// Add Angular integrations if Angular is available
if ((typeof angular === 'object') && angular.module) {

  var IonicAngularPush = null;

  angular.module('ionic.service.push', [])

  /**
   * IonicPushAction Service
   *
   * A utility service to kick off misc features as part of the Ionic Push service
   */
  .factory('$ionicPushAction', ['$state', function($state) {

    function PushActionService() {}

    /**
     * State Navigation
     *
     * Attempts to navigate to a new view if a push notification payload contains:
     *
     *   - $state {String} The state name (e.g 'tab.chats')
     *   - $stateParams {Object} Provided state (url) params
     *
     * Find more info about state navigation and params:
     * https://github.com/angular-ui/ui-router/wiki
     *
     * @param {object} notification Notification Object
     * @return {void}
     */
    PushActionService.prototype.notificationNavigation = function(notification) {
      var state = notification.payload.$state || false;
      var stateParams = notification.payload.$stateParams || {};
      if (state) {
        $state.go(state, stateParams);
      }
    };

    return new PushActionService();
  }])

  .factory('$ionicPush', [function() {
    if (!IonicAngularPush) {
      IonicAngularPush = new Ionic.Push({ 'deferInit': true });
    }
    return IonicAngularPush;
  }])

  .run(['$ionicCore', '$ionicPush', '$ionicPushAction', function($ionicCore, $ionicPush, $ionicPushAction) {
    // This is what kicks off the state redirection when a push notificaiton has the relevant details
    $ionicCore.emitter.on('push:processNotification', function(notification) {
      notification = Ionic.PushMessage.fromPluginJSON(notification);
      if (notification && notification.app) {
        if (notification.app.asleep === true || notification.app.closed === true) {
          $ionicPushAction.notificationNavigation(notification);
        }
      }
    });

  }]);
}

},{}]},{},[47,45,43,44,48,46,25])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2VzNS9hbmFseXRpY3MvYW5hbHl0aWNzLmpzIiwiZGlzdC9lczUvYW5hbHl0aWNzL2luZGV4LmpzIiwiZGlzdC9lczUvYW5hbHl0aWNzL3NlcmlhbGl6ZXJzLmpzIiwiZGlzdC9lczUvYW5hbHl0aWNzL3N0b3JhZ2UuanMiLCJkaXN0L2VzNS9hdXRoL2F1dGguanMiLCJkaXN0L2VzNS9hdXRoL2luZGV4LmpzIiwiZGlzdC9lczUvY29yZS9hcHAuanMiLCJkaXN0L2VzNS9jb3JlL2NsaWVudC5qcyIsImRpc3QvZXM1L2NvcmUvY29uZmlnLmpzIiwiZGlzdC9lczUvY29yZS9jb3Jkb3ZhLmpzIiwiZGlzdC9lczUvY29yZS9jb3JlLmpzIiwiZGlzdC9lczUvY29yZS9kYXRhLXR5cGVzLmpzIiwiZGlzdC9lczUvY29yZS9kZXZpY2UuanMiLCJkaXN0L2VzNS9jb3JlL2V2ZW50cy5qcyIsImRpc3QvZXM1L2NvcmUvaW5kZXguanMiLCJkaXN0L2VzNS9jb3JlL2xvZ2dlci5qcyIsImRpc3QvZXM1L2NvcmUvcHJvbWlzZS5qcyIsImRpc3QvZXM1L2NvcmUvcmVxdWVzdC5qcyIsImRpc3QvZXM1L2NvcmUvc3RvcmFnZS5qcyIsImRpc3QvZXM1L2NvcmUvdXNlci5qcyIsImRpc3QvZXM1L2RlcGxveS9kZXBsb3kuanMiLCJkaXN0L2VzNS9kZXBsb3kvaW5kZXguanMiLCJkaXN0L2VzNS9lbnZpcm9ubWVudHMvZW52aXJvbm1lbnRzLmpzIiwiZGlzdC9lczUvZW52aXJvbm1lbnRzL2luZGV4LmpzIiwiZGlzdC9lczUvaW5kZXguanMiLCJkaXN0L2VzNS9pbnNpZ2h0cy9pbmRleC5qcyIsImRpc3QvZXM1L2luc2lnaHRzL2luc2lnaHRzLmpzIiwiZGlzdC9lczUvbGlua3MvaW5kZXguanMiLCJkaXN0L2VzNS9saW5rcy9saW5rcy5qcyIsImRpc3QvZXM1L3B1c2gvaW5kZXguanMiLCJkaXN0L2VzNS9wdXNoL3B1c2gtZGV2LmpzIiwiZGlzdC9lczUvcHVzaC9wdXNoLW1lc3NhZ2UuanMiLCJkaXN0L2VzNS9wdXNoL3B1c2gtdG9rZW4uanMiLCJkaXN0L2VzNS9wdXNoL3B1c2guanMiLCJkaXN0L2VzNS91dGlsL2luZGV4LmpzIiwiZGlzdC9lczUvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9ub2RlX21vZHVsZXMvcmVkdWNlLWNvbXBvbmVudC9pbmRleC5qcyIsInNyYy9hbmFseXRpY3MvYW5ndWxhci5qcyIsInNyYy9hdXRoL2FuZ3VsYXIuanMiLCJzcmMvY29yZS9hbmd1bGFyLmpzIiwic3JjL2RlcGxveS9hbmd1bGFyLmpzIiwic3JjL2VzNS5qcyIsInNyYy9wdXNoL2FuZ3VsYXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVxdWVzdF8xID0gcmVxdWlyZSgnLi4vY29yZS9yZXF1ZXN0Jyk7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vY29yZS9wcm9taXNlJyk7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi4vY29yZS9jb3JlJyk7XG52YXIgc3RvcmFnZV8xID0gcmVxdWlyZSgnLi9zdG9yYWdlJyk7XG52YXIgdXNlcl8xID0gcmVxdWlyZSgnLi4vY29yZS91c2VyJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgQU5BTFlUSUNTX0tFWSA9IG51bGw7XG52YXIgREVGRVJfUkVHSVNURVIgPSAnREVGRVJfUkVHSVNURVInO1xudmFyIG9wdGlvbnMgPSB7fTtcbnZhciBnbG9iYWxQcm9wZXJ0aWVzID0ge307XG52YXIgZ2xvYmFsUHJvcGVydGllc0ZucyA9IFtdO1xudmFyIEFuYWx5dGljcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5hbHl0aWNzKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hJbnRlcnZhbFRpbWUgPSAzMDtcbiAgICAgICAgdGhpcy5fdXNlRXZlbnRDYWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2VydmljZUhvc3QgPSBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0VVJMKCdhbmFseXRpY3MnKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY29yZV8xLklvbmljUGxhdGZvcm0uc3RvcmFnZTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBzdG9yYWdlXzEuQnVja2V0U3RvcmFnZSgnaW9uaWNfYW5hbHl0aWNzJyk7XG4gICAgICAgIHRoaXMuX2FkZEdsb2JhbFByb3BlcnR5RGVmYXVsdHMoKTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gREVGRVJfUkVHSVNURVIpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBbmFseXRpY3MucHJvdG90eXBlLl9hZGRHbG9iYWxQcm9wZXJ0eURlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEdsb2JhbFByb3BlcnRpZXMoZnVuY3Rpb24gKGV2ZW50Q29sbGVjdGlvbiwgZXZlbnREYXRhKSB7XG4gICAgICAgICAgICBldmVudERhdGEuX3VzZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHVzZXJfMS5Vc2VyLmN1cnJlbnQoKSkpO1xuICAgICAgICAgICAgZXZlbnREYXRhLl9hcHAgPSB7XG4gICAgICAgICAgICAgICAgJ2FwcF9pZCc6IGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLFxuICAgICAgICAgICAgICAgICdhbmFseXRpY3NfdmVyc2lvbic6IGNvcmVfMS5Jb25pY1BsYXRmb3JtLnZlcnNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuYWx5dGljcy5wcm90b3R5cGUsIFwiaGFzVmFsaWRTZXR0aW5nc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcHBfaWQnKSB8fCAhY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBpX2tleScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdJb25pYyBBbmFseXRpY3M6IEEgdmFsaWQgYXBwX2lkIGFuZCBhcGlfa2V5IGFyZSByZXF1aXJlZCBiZWZvcmUgeW91IGNhbiB1dGlsaXplICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW5hbHl0aWNzIHByb3Blcmx5LiBTZWUgaHR0cDovL2RvY3MuaW9uaWMuaW8vdjEuMC9kb2NzL2lvLXF1aWNrLXN0YXJ0JztcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbyhtc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5hbHl0aWNzLnByb3RvdHlwZSwgXCJkaXNwYXRjaEludGVydmFsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hJbnRlcnZhbFRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBTZXQgaG93IG9mdGVuIHdlIHNob3VsZCBzZW5kIGJhdGNoZWQgZXZlbnRzLCBpbiBzZWNvbmRzLlxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG8gMCB0byBkaXNhYmxlIGV2ZW50IGNhY2hpbmdcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSW50ZXJ2YWxUaW1lID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZXhpc3RpbmcgaW50ZXJ2YWxcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwYXRjaGVyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5fZGlzcGF0Y2hlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hlciA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHNlbGYuX2Rpc3BhdGNoUXVldWUoKTsgfSwgdmFsdWUgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VFdmVudENhY2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRXZlbnRDYWNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFuYWx5dGljcy5wcm90b3R5cGUuX2VucXVldWVFdmVudCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uTmFtZSwgZXZlbnREYXRhKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRyeVJ1bikge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczogZXZlbnQgcmVjaWV2ZWQgYnV0IG5vdCBzZW50IChkcnlSdW4gYWN0aXZlKTonKTtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBBbmFseXRpY3M6JywgY29sbGVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczonLCBldmVudERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBBbmFseXRpY3M6IGVucXVldWluZyBldmVudCB0byBzZW5kIGxhdGVyOicpO1xuICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgQW5hbHl0aWNzOicsIGNvbGxlY3Rpb25OYW1lKTtcbiAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczonLCBldmVudERhdGEpO1xuICAgICAgICAvLyBBZGQgdGltZXN0YW1wIHByb3BlcnR5IHRvIHRoZSBkYXRhXG4gICAgICAgIGlmICghZXZlbnREYXRhLmtlZW4pIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5rZWVuID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnREYXRhLmtlZW4udGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAvLyBBZGQgdGhlIGRhdGEgdG8gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBldmVudFF1ZXVlID0gdGhpcy5jYWNoZS5nZXQoJ2V2ZW50X3F1ZXVlJykgfHwge307XG4gICAgICAgIGlmICghZXZlbnRRdWV1ZVtjb2xsZWN0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIGV2ZW50UXVldWVbY29sbGVjdGlvbk5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRRdWV1ZVtjb2xsZWN0aW9uTmFtZV0ucHVzaChldmVudERhdGEpO1xuICAgICAgICAvLyBXcml0ZSB0aGUgcXVldWUgdG8gZGlza1xuICAgICAgICB0aGlzLmNhY2hlLnNldCgnZXZlbnRfcXVldWUnLCBldmVudFF1ZXVlKTtcbiAgICB9O1xuICAgIEFuYWx5dGljcy5wcm90b3R5cGUuX3JlcXVlc3RBbmFseXRpY3NLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICdtZXRob2QnOiAnR0VUJyxcbiAgICAgICAgICAgICdqc29uJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmknOiBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0VVJMKCdhcGknKSArICcvYXBpL3YxL2FwcC8nICsgY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJykgKyAnL2tleXMvd3JpdGUnLFxuICAgICAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnYmFzaWMgJyArIGJ0b2EoY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJykgKyAnOicgKyBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcGlfa2V5JykpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXF1ZXN0XzEucmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICBBbmFseXRpY3MucHJvdG90eXBlLl9wb3N0RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICduYW1lJzogW2RhdGFdXG4gICAgICAgIH07XG4gICAgICAgIGlmICghQU5BTFlUSUNTX0tFWSkge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmVycm9yKCdJb25pYyBBbmFseXRpY3M6IENhbm5vdCBzZW5kIGV2ZW50cyB0byB0aGUgYW5hbHl0aWNzIHNlcnZlciB3aXRob3V0IGFuIEFuYWx5dGljcyBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgJ21ldGhvZCc6ICdQT1NUJyxcbiAgICAgICAgICAgICd1cmwnOiB0aGlzLl9zZXJ2aWNlSG9zdCArICcvYXBpL3YxL2V2ZW50cy8nICsgY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksXG4gICAgICAgICAgICAnanNvbic6IHBheWxvYWQsXG4gICAgICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IEFOQUxZVElDU19LRVlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RfMS5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICB9O1xuICAgIEFuYWx5dGljcy5wcm90b3R5cGUuX3Bvc3RFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgICAgIGlmICghQU5BTFlUSUNTX0tFWSkge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczogQ2Fubm90IHNlbmQgZXZlbnRzIHRvIHRoZSBhbmFseXRpY3Mgc2VydmVyIHdpdGhvdXQgYW4gQW5hbHl0aWNzIGtleS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnbWV0aG9kJzogJ1BPU1QnLFxuICAgICAgICAgICAgJ3VybCc6IHRoaXMuX3NlcnZpY2VIb3N0ICsgJy9hcGkvdjEvZXZlbnRzLycgKyBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcHBfaWQnKSxcbiAgICAgICAgICAgICdqc29uJzogZXZlbnRzLFxuICAgICAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBBTkFMWVRJQ1NfS0VZXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXF1ZXN0XzEucmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgfTtcbiAgICBBbmFseXRpY3MucHJvdG90eXBlLl9kaXNwYXRjaFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudFF1ZXVlID0gdGhpcy5jYWNoZS5nZXQoJ2V2ZW50X3F1ZXVlJykgfHwge307XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhldmVudFF1ZXVlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcmVfMS5Jb25pY1BsYXRmb3JtLmRldmljZS5pc0Nvbm5lY3RlZFRvTmV0d29yaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zdG9yYWdlLmxvY2tlZEFzeW5jQ2FsbChzZWxmLmNhY2hlLnNjb3BlZEtleSgnZXZlbnRfZGlzcGF0Y2gnKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3Bvc3RFdmVudHMoZXZlbnRRdWV1ZSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5jYWNoZS5zZXQoJ2V2ZW50X3F1ZXVlJywge30pO1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczogc2VudCBldmVudHMnKTtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBBbmFseXRpY3M6JywgZXZlbnRRdWV1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZURpc3BhdGNoRXJyb3IoZXJyLCB0aGlzLCBldmVudFF1ZXVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBbmFseXRpY3MucHJvdG90eXBlLl9nZXRSZXF1ZXN0U3RhdHVzQ29kZSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciByZXNwb25zZUNvZGUgPSBudWxsO1xuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LnJlcXVlc3RJbmZvLl9sYXN0UmVzdWx0ICYmIHJlcXVlc3QucmVxdWVzdEluZm8uX2xhc3RSZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICByZXNwb25zZUNvZGUgPSByZXF1ZXN0LnJlcXVlc3RJbmZvLl9sYXN0UmVzdWx0LnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VDb2RlO1xuICAgIH07XG4gICAgQW5hbHl0aWNzLnByb3RvdHlwZS5faGFuZGxlRGlzcGF0Y2hFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgcmVxdWVzdCwgZXZlbnRRdWV1ZSkge1xuICAgICAgICB2YXIgcmVzcG9uc2VDb2RlID0gdGhpcy5fZ2V0UmVxdWVzdFN0YXR1c0NvZGUocmVxdWVzdCk7XG4gICAgICAgIGlmIChlcnJvciA9PT0gJ2xhc3RfY2FsbF9pbnRlcnJ1cHRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KCdldmVudF9xdWV1ZScsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBjb25uZWN0IHRvIHRoZSBzZXJ2ZXIgYXQgYWxsIC0+IGtlZXAgZXZlbnRzXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQ29kZSkge1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgQW5hbHl0aWNzOiBFcnJvciBzZW5kaW5nIGFuYWx5dGljcyBkYXRhOiBGYWlsZWQgdG8gY29ubmVjdCB0byBhbmFseXRpY3Mgc2VydmVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoJ2V2ZW50X3F1ZXVlJywge30pO1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgQW5hbHl0aWNzOiBFcnJvciBzZW5kaW5nIGFuYWx5dGljcyBkYXRhOiBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3InKTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIEFuYWx5dGljczonLCBldmVudFF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5hbHl0aWNzLnByb3RvdHlwZS5faGFuZGxlUmVnaXN0ZXJFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgcmVzcG9uc2VDb2RlID0gdGhpcy5fZ2V0UmVxdWVzdFN0YXR1c0NvZGUocmVxdWVzdCk7XG4gICAgICAgIHZhciBkb2NzID0gJyBTZWUgaHR0cDovL2RvY3MuaW9uaWMuaW8vdjEuMC9kb2NzL2lvLXF1aWNrLXN0YXJ0JztcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgQW5hbHl0aWNzOiBUaGUgYXBpIGtleSBhbmQgYXBwIGlkIHlvdSBwcm92aWRlZCBkaWQgbm90IHJlZ2lzdGVyIG9uIHRoZSBzZXJ2ZXIuICcgKyBkb2NzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDA0OlxuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgQW5hbHl0aWNzOiBUaGUgYXBwIGlkIHlvdSBwcm92aWRlZCAoXCInICsgY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJykgKyAnXCIpIHdhcyBub3QgZm91bmQuJyArIGRvY3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIEFuYWx5dGljczogVW5hYmxlIHRvIHJlcXVlc3QgYW5hbHl0aWNzIGtleS4nKTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIEFuYWx5dGljczonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBhbmFseXRpY3Mga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyBSZWdpc3RyYXRpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSByZWdpc3RlciBwcm9taXNlXG4gICAgICovXG4gICAgQW5hbHl0aWNzLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbGlkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5zaWxlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBBbmFseXRpY3M6IGRyeVJ1biBtb2RlIGlzIGFjdGl2ZS4gQW5hbHl0aWNzIHdpbGwgbm90IHNlbmQgYW55IGV2ZW50cy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1ZXN0QW5hbHl0aWNzS2V5KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBBTkFMWVRJQ1NfS0VZID0gcmVzdWx0LnBheWxvYWQud3JpdGVfa2V5O1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczogc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQgYW5hbHl0aWNzIGtleScpO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEludGVydmFsID0gc2VsZi5kaXNwYXRjaEludGVydmFsO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVSZWdpc3RlckVycm9yKGVycm9yLCB0aGlzKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIEFuYWx5dGljcy5wcm90b3R5cGUuc2V0R2xvYmFsUHJvcGVydGllcyA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9ICh0eXBlb2YgcHJvcCk7XG4gICAgICAgIHN3aXRjaCAocHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXNba2V5XSA9IHByb3Bba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllc0Zucy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIEFuYWx5dGljczogc2V0R2xvYmFsUHJvcGVydGllcyBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFuYWx5dGljcy5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoZXZlbnRDb2xsZWN0aW9uLCBldmVudERhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbGlkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50RGF0YSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgZXZlbnQgZGF0YSB0byBhdm9pZCBtb2RpZnlpbmcgaXRcbiAgICAgICAgICAgIGV2ZW50RGF0YSA9IHV0aWxfMS5kZWVwRXh0ZW5kKHt9LCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50RGF0YVtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGFba2V5XSA9IGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JhbFByb3BlcnRpZXNGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGdsb2JhbFByb3BlcnRpZXNGbnNbaV07XG4gICAgICAgICAgICBmbi5jYWxsKG51bGwsIGV2ZW50Q29sbGVjdGlvbiwgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdXNlRXZlbnRDYWNoaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9lbnF1ZXVlRXZlbnQoZXZlbnRDb2xsZWN0aW9uLCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFuYWx5dGljczogZHJ5UnVuIGFjdGl2ZSwgd2lsbCBub3Qgc2VuZCBldmVudCcpO1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBBbmFseXRpY3M6JywgZXZlbnRDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgQW5hbHl0aWNzOicsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3N0RXZlbnQoZXZlbnRDb2xsZWN0aW9uLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBbmFseXRpY3MucHJvdG90eXBlLnVuc2V0R2xvYmFsUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSAodHlwZW9mIHByb3ApO1xuICAgICAgICBzd2l0Y2ggKHByb3BUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxQcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHZhciBpID0gZ2xvYmFsUHJvcGVydGllc0Zucy5pbmRleE9mKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIEFuYWx5dGljczogVGhlIGZ1bmN0aW9uIHBhc3NlZCB0byB1bnNldEdsb2JhbFByb3BlcnR5IHdhcyBub3QgYSBnbG9iYWwgcHJvcGVydHkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXNGbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIEFuYWx5dGljczogdW5zZXRHbG9iYWxQcm9wZXJ0eSBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFuYWx5dGljcztcbn0oKSk7XG5leHBvcnRzLkFuYWx5dGljcyA9IEFuYWx5dGljcztcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vYW5hbHl0aWNzJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9zZXJpYWxpemVycycpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3RvcmFnZScpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIERPTVNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERPTVNlcmlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIERPTVNlcmlhbGl6ZXIucHJvdG90eXBlLmVsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgdXAgdGhlIGRvbVxuICAgICAgICB2YXIgc2VsZWN0b3JzID0gW107XG4gICAgICAgIHdoaWxlIChlbGVtZW50LnRhZ05hbWUgIT09ICdIVE1MJykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9ICcjJyArIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9ICcuJyArIGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkSW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGVsZW1lbnQucGFyZW50Tm9kZS5jaGlsZHJlbiwgZWxlbWVudCk7XG4gICAgICAgICAgICBzZWxlY3RvciArPSAnOm50aC1jaGlsZCgnICsgKGNoaWxkSW5kZXggKyAxKSArICcpJztcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9ycy5yZXZlcnNlKCkuam9pbignPicpO1xuICAgIH07XG4gICAgRE9NU2VyaWFsaXplci5wcm90b3R5cGUuZWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyAxLiBpb24tdHJhY2stbmFtZSBkaXJlY3RpdmVcbiAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaW9uLXRyYWNrLW5hbWUnKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIDIuIGlkXG4gICAgICAgIHZhciBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBubyB1bmlxdWUgaWRlbnRpZmllciAtLT4gcmV0dXJuIG51bGxcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRE9NU2VyaWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLkRPTVNlcmlhbGl6ZXIgPSBET01TZXJpYWxpemVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi4vY29yZS9jb3JlJyk7XG52YXIgQnVja2V0U3RvcmFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVja2V0U3RvcmFnZShuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYmFzZVN0b3JhZ2UgPSBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5zdG9yYWdlO1xuICAgIH1cbiAgICBCdWNrZXRTdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdG9yYWdlLnJldHJpZXZlT2JqZWN0KHRoaXMuc2NvcGVkS2V5KGtleSkpO1xuICAgIH07XG4gICAgQnVja2V0U3RvcmFnZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0b3JhZ2Uuc3RvcmVPYmplY3QodGhpcy5zY29wZWRLZXkoa2V5KSwgdmFsdWUpO1xuICAgIH07XG4gICAgQnVja2V0U3RvcmFnZS5wcm90b3R5cGUuc2NvcGVkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJ18nICsga2V5ICsgJ18nICsgY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVja2V0U3RvcmFnZTtcbn0oKSk7XG5leHBvcnRzLkJ1Y2tldFN0b3JhZ2UgPSBCdWNrZXRTdG9yYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuLi9jb3JlL3Byb21pc2UnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCcuLi9jb3JlL2NvcmUnKTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKCcuLi9jb3JlL3N0b3JhZ2UnKTtcbnZhciB1c2VyXzEgPSByZXF1aXJlKCcuLi9jb3JlL3VzZXInKTtcbnZhciBhdXRoTW9kdWxlcyA9IHt9O1xudmFyIGF1dGhUb2tlbjtcbnZhciBUZW1wVG9rZW5Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wVG9rZW5Db250ZXh0KCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgc3RvcmFnZV8xLlNlc3Npb25TdG9yYWdlU3RyYXRlZ3koKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBUb2tlbkNvbnRleHQucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lvbmljX2lvX2F1dGhfJyArIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW1wVG9rZW5Db250ZXh0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5sYWJlbCk7XG4gICAgfTtcbiAgICBUZW1wVG9rZW5Db250ZXh0LnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KHRoaXMubGFiZWwsIHRva2VuKTtcbiAgICB9O1xuICAgIFRlbXBUb2tlbkNvbnRleHQucHJvdG90eXBlLmdldFJhd0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0KHRoaXMubGFiZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBUb2tlbkNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5UZW1wVG9rZW5Db250ZXh0ID0gVGVtcFRva2VuQ29udGV4dDtcbnZhciBUb2tlbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IHN0b3JhZ2VfMS5Mb2NhbFN0b3JhZ2VTdHJhdGVneSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9rZW5Db250ZXh0LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdpb25pY19pb19hdXRoXycgKyBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcHBfaWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVG9rZW5Db250ZXh0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodG9rZW5Db250ZXh0LmxhYmVsKTtcbiAgICB9O1xuICAgIFRva2VuQ29udGV4dC5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh0b2tlbkNvbnRleHQubGFiZWwsIHRva2VuKTtcbiAgICB9O1xuICAgIFRva2VuQ29udGV4dC5wcm90b3R5cGUuZ2V0UmF3RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodG9rZW5Db250ZXh0LmxhYmVsKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2tlbkNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5Ub2tlbkNvbnRleHQgPSBUb2tlbkNvbnRleHQ7XG52YXIgdGVtcFRva2VuQ29udGV4dCA9IG5ldyBUZW1wVG9rZW5Db250ZXh0KCk7XG52YXIgdG9rZW5Db250ZXh0ID0gbmV3IFRva2VuQ29udGV4dCgpO1xuZnVuY3Rpb24gc3RvcmVUb2tlbihvcHRpb25zLCB0b2tlbikge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG9yaWdpbmFsVG9rZW4gPSBhdXRoVG9rZW47XG4gICAgYXV0aFRva2VuID0gdG9rZW47XG4gICAgaWYgKG9wdGlvbnMucmVtZW1iZXIpIHtcbiAgICAgICAgdG9rZW5Db250ZXh0LnN0b3JlKGF1dGhUb2tlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0ZW1wVG9rZW5Db250ZXh0LnN0b3JlKGF1dGhUb2tlbik7XG4gICAgfVxuICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmVtaXR0ZXIuZW1pdCgnYXV0aDp0b2tlbi1jaGFuZ2VkJywgeyAnb2xkJzogb3JpZ2luYWxUb2tlbiwgJ25ldyc6IGF1dGhUb2tlbiB9KTtcbn1cbmZ1bmN0aW9uIGdldEF1dGhFcnJvckRldGFpbHMoZXJyKSB7XG4gICAgdmFyIGRldGFpbHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBkZXRhaWxzID0gZXJyLnJlc3BvbnNlLmJvZHkuZXJyb3IuZGV0YWlscztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFpbHM7XG59XG52YXIgQXV0aCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0aCgpIHtcbiAgICB9XG4gICAgQXV0aC5pc0F1dGhlbnRpY2F0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2VuQ29udGV4dC5nZXRSYXdEYXRhKCk7XG4gICAgICAgIHZhciB0ZW1wVG9rZW4gPSB0ZW1wVG9rZW5Db250ZXh0LmdldFJhd0RhdGEoKTtcbiAgICAgICAgaWYgKHRlbXBUb2tlbiB8fCB0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQXV0aC5sb2dpbiA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgb3B0aW9ucywgZGF0YSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB2YXIgY29udGV4dCA9IGF1dGhNb2R1bGVzW21vZHVsZUlkXSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGNsYXNzIGlzIGludmFsaWQgb3IgbWlzc2luZzonICsgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5hdXRoZW50aWNhdGUuYXBwbHkoY29udGV4dCwgW29wdGlvbnMsIGRhdGFdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVzZXJfMS5Vc2VyLnNlbGYoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1c2VyKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgQXV0aC5zaWdudXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGF1dGhNb2R1bGVzWydiYXNpYyddIHx8IGZhbHNlO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gY2xhc3MgaXMgaW52YWxpZCBvciBtaXNzaW5nOicgKyBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dC5zaWdudXAuYXBwbHkoY29udGV4dCwgW2RhdGFdKTtcbiAgICB9O1xuICAgIEF1dGgubG9nb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0b2tlbkNvbnRleHQuZGVsZXRlKCk7XG4gICAgICAgIHRlbXBUb2tlbkNvbnRleHQuZGVsZXRlKCk7XG4gICAgICAgIHVzZXJfMS5Vc2VyLmN1cnJlbnQoKS5jbGVhcigpO1xuICAgIH07XG4gICAgQXV0aC5yZWdpc3RlciA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgbW9kdWxlKSB7XG4gICAgICAgIGlmICghYXV0aE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gICAgICAgICAgICBhdXRoTW9kdWxlc1ttb2R1bGVJZF0gPSBtb2R1bGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGguZ2V0VXNlclRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXNlcnRva2VuID0gdG9rZW5Db250ZXh0LmdldFJhd0RhdGEoKTtcbiAgICAgICAgdmFyIHRlbXB0b2tlbiA9IHRlbXBUb2tlbkNvbnRleHQuZ2V0UmF3RGF0YSgpO1xuICAgICAgICB2YXIgdG9rZW4gPSB0ZW1wdG9rZW4gfHwgdXNlcnRva2VuO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICByZXR1cm4gQXV0aDtcbn0oKSk7XG5leHBvcnRzLkF1dGggPSBBdXRoO1xudmFyIEF1dGhUeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoVHlwZShjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBBdXRoVHlwZS5wcm90b3R5cGUuaW5BcHBCcm93c2VyRmxvdyA9IGZ1bmN0aW9uIChhdXRoT3B0aW9ucywgb3B0aW9ucywgZGF0YSkge1xuICAgICAgICBpZiAoYXV0aE9wdGlvbnMgPT09IHZvaWQgMCkgeyBhdXRoT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuY29yZG92YSB8fCAhd2luZG93LmNvcmRvdmEuSW5BcHBCcm93c2VyKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ01pc3NpbmcgSW5BcHBCcm93c2VyIHBsdWdpbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMudXJpX21ldGhvZCA/IG9wdGlvbnMudXJpX21ldGhvZCA6ICdQT1NUJztcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXIgPyAnLycgKyBvcHRpb25zLnByb3ZpZGVyIDogJyc7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgXCIvYXV0aC9sb2dpblwiICsgcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgLnNlbmQoe1xuICAgICAgICAgICAgICAgICdhcHBfaWQnOiBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcHBfaWQnKSxcbiAgICAgICAgICAgICAgICAnY2FsbGJhY2snOiBvcHRpb25zLmNhbGxiYWNrX3VyaSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAnZGF0YSc6IGRhdGFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYyA9IHJlcy5wYXlsb2FkLmRhdGEudXJsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEJyb3dzZXIgPSB3aW5kb3cuY29yZG92YS5JbkFwcEJyb3dzZXIub3Blbihsb2MsICdfYmxhbmsnLCAnbG9jYXRpb249bm8sY2xlYXJjYWNoZT15ZXMsY2xlYXJzZXNzaW9uY2FjaGU9eWVzJyk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBCcm93c2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS51cmwuc2xpY2UoMCwgMjApID09PSAnaHR0cDovL2F1dGguaW9uaWMuaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gZGF0YS51cmwuc3BsaXQoJyMnKVswXS5zcGxpdCgnPycpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbVBhcnRzID0gcXVlcnlTdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFyYW1QYXJ0c1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbcGFydFswXV0gPSBwYXJ0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVRva2VuKGF1dGhPcHRpb25zLCBwYXJhbXMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBCcm93c2VyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEJyb3dzZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhUeXBlO1xufSgpKTtcbnZhciBCYXNpY0F1dGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNpY0F1dGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzaWNBdXRoKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmFzaWNBdXRoLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgZGF0YSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLmNsaWVudC5wb3N0KCcvYXV0aC9sb2dpbicpXG4gICAgICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgICAnYXBwX2lkJzogY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksXG4gICAgICAgICAgICAnZW1haWwnOiBkYXRhLmVtYWlsLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJzogZGF0YS5wYXNzd29yZFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlVG9rZW4ob3B0aW9ucywgcmVzLmJvZHkuZGF0YS50b2tlbik7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgQmFzaWNBdXRoLnByb3RvdHlwZS5zaWdudXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB2YXIgdXNlckRhdGEgPSB7XG4gICAgICAgICAgICAnYXBwX2lkJzogY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksXG4gICAgICAgICAgICAnZW1haWwnOiBkYXRhLmVtYWlsLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJzogZGF0YS5wYXNzd29yZFxuICAgICAgICB9O1xuICAgICAgICAvLyBvcHRpb25hbCBkZXRhaWxzXG4gICAgICAgIGlmIChkYXRhLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICB1c2VyRGF0YS51c2VybmFtZSA9IGRhdGEudXNlcm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgIHVzZXJEYXRhLmltYWdlID0gZGF0YS5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5uYW1lKSB7XG4gICAgICAgICAgICB1c2VyRGF0YS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmN1c3RvbSkge1xuICAgICAgICAgICAgdXNlckRhdGEuY3VzdG9tID0gZGF0YS5jdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQucG9zdCgnL2F1dGgvdXNlcnMnKVxuICAgICAgICAgICAgLnNlbmQodXNlckRhdGEpXG4gICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZGV0YWlscyA9IGdldEF1dGhFcnJvckRldGFpbHMoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGV0YWlscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRldGFpbCA9IGRldGFpbHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLmVycm9yX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZGV0YWlsLmVycm9yX3R5cGUgKyAnXycgKyBkZXRhaWwucGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHsgJ2Vycm9ycyc6IGVycm9ycyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNpY0F1dGg7XG59KEF1dGhUeXBlKSk7XG52YXIgQ3VzdG9tQXV0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbUF1dGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQXV0aCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEN1c3RvbUF1dGgucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBkYXRhKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmluQXBwQnJvd3NlckZsb3cob3B0aW9ucywgeyAncHJvdmlkZXInOiAnY3VzdG9tJyB9LCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21BdXRoO1xufShBdXRoVHlwZSkpO1xudmFyIFR3aXR0ZXJBdXRoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHdpdHRlckF1dGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHdpdHRlckF1dGgoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUd2l0dGVyQXV0aC5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGRhdGEpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BcHBCcm93c2VyRmxvdyhvcHRpb25zLCB7ICdwcm92aWRlcic6ICd0d2l0dGVyJyB9LCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBUd2l0dGVyQXV0aDtcbn0oQXV0aFR5cGUpKTtcbnZhciBGYWNlYm9va0F1dGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGYWNlYm9va0F1dGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmFjZWJvb2tBdXRoKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRmFjZWJvb2tBdXRoLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgZGF0YSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbkFwcEJyb3dzZXJGbG93KG9wdGlvbnMsIHsgJ3Byb3ZpZGVyJzogJ2ZhY2Vib29rJyB9LCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBGYWNlYm9va0F1dGg7XG59KEF1dGhUeXBlKSk7XG52YXIgR2l0aHViQXV0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdpdGh1YkF1dGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2l0aHViQXV0aCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdpdGh1YkF1dGgucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBkYXRhKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmluQXBwQnJvd3NlckZsb3cob3B0aW9ucywgeyAncHJvdmlkZXInOiAnZ2l0aHViJyB9LCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBHaXRodWJBdXRoO1xufShBdXRoVHlwZSkpO1xudmFyIEdvb2dsZUF1dGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHb29nbGVBdXRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdvb2dsZUF1dGgoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHb29nbGVBdXRoLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgZGF0YSkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbkFwcEJyb3dzZXJGbG93KG9wdGlvbnMsIHsgJ3Byb3ZpZGVyJzogJ2dvb2dsZScgfSwgZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gR29vZ2xlQXV0aDtcbn0oQXV0aFR5cGUpKTtcbnZhciBJbnN0YWdyYW1BdXRoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5zdGFncmFtQXV0aCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnN0YWdyYW1BdXRoKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW5zdGFncmFtQXV0aC5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGRhdGEpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BcHBCcm93c2VyRmxvdyhvcHRpb25zLCB7ICdwcm92aWRlcic6ICdpbnN0YWdyYW0nIH0sIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEluc3RhZ3JhbUF1dGg7XG59KEF1dGhUeXBlKSk7XG52YXIgTGlua2VkSW5BdXRoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlua2VkSW5BdXRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtlZEluQXV0aCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExpbmtlZEluQXV0aC5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIGRhdGEpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BcHBCcm93c2VyRmxvdyhvcHRpb25zLCB7ICdwcm92aWRlcic6ICdsaW5rZWRpbicgfSwgZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua2VkSW5BdXRoO1xufShBdXRoVHlwZSkpO1xuQXV0aC5yZWdpc3RlcignYmFzaWMnLCBuZXcgQmFzaWNBdXRoKGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNsaWVudCkpO1xuQXV0aC5yZWdpc3RlcignY3VzdG9tJywgbmV3IEN1c3RvbUF1dGgoY29yZV8xLklvbmljUGxhdGZvcm0uY2xpZW50KSk7XG5BdXRoLnJlZ2lzdGVyKCdmYWNlYm9vaycsIG5ldyBGYWNlYm9va0F1dGgoY29yZV8xLklvbmljUGxhdGZvcm0uY2xpZW50KSk7XG5BdXRoLnJlZ2lzdGVyKCdnaXRodWInLCBuZXcgR2l0aHViQXV0aChjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jbGllbnQpKTtcbkF1dGgucmVnaXN0ZXIoJ2dvb2dsZScsIG5ldyBHb29nbGVBdXRoKGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNsaWVudCkpO1xuQXV0aC5yZWdpc3RlcignaW5zdGFncmFtJywgbmV3IEluc3RhZ3JhbUF1dGgoY29yZV8xLklvbmljUGxhdGZvcm0uY2xpZW50KSk7XG5BdXRoLnJlZ2lzdGVyKCdsaW5rZWRpbicsIG5ldyBMaW5rZWRJbkF1dGgoY29yZV8xLklvbmljUGxhdGZvcm0uY2xpZW50KSk7XG5BdXRoLnJlZ2lzdGVyKCd0d2l0dGVyJywgbmV3IFR3aXR0ZXJBdXRoKGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNsaWVudCkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuX19leHBvcnQocmVxdWlyZSgnLi9hdXRoJykpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgcHJpdmF0ZURhdGEgPSB7fTtcbmZ1bmN0aW9uIHByaXZhdGVWYXIoa2V5KSB7XG4gICAgcmV0dXJuIHByaXZhdGVEYXRhW2tleV0gfHwgbnVsbDtcbn1cbnZhciBBcHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcChhcHBJZCwgYXBpS2V5KSB7XG4gICAgICAgIGlmICghYXBwSWQgfHwgYXBwSWQgPT09ICcnKSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgQXBwOiBObyBhcHBfaWQgd2FzIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcGlLZXkgfHwgYXBpS2V5ID09PSAnJykge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIEFwcDogTm8gYXBpX2tleSB3YXMgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcml2YXRlRGF0YS5pZCA9IGFwcElkO1xuICAgICAgICBwcml2YXRlRGF0YS5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIC8vIG90aGVyIGNvbmZpZyB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgdGhpcy5kZXZQdXNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5nY21LZXkgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaXZhdGVWYXIoJ2lkJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHAucHJvdG90eXBlLCBcImFwaUtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaXZhdGVWYXIoJ2FwaUtleScpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBcHAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJzxBcHAgW1xcJycgKyB0aGlzLmlkICsgJ1xcJz4nO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcDtcbn0oKSk7XG5leHBvcnRzLkFwcCA9IEFwcDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG52YXIgQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnQoYmFzZVVybCwgdG9rZW4sIHJlcSAvLyBUT0RPOiB1c2Ugc3VwZXJhZ2VudCB0eXBlc1xuICAgICAgICApIHtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXEgPSByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgfVxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBsZW1lbnQodGhpcy5yZXEuZ2V0LCBlbmRwb2ludCk7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcGxlbWVudCh0aGlzLnJlcS5wb3N0LCBlbmRwb2ludCk7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLnB1dCwgZW5kcG9pbnQpO1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLnBhdGNoLCBlbmRwb2ludCk7XG4gICAgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLmRlbGV0ZSwgZW5kcG9pbnQpO1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgZW5kcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcGxlbWVudCh0aGlzLnJlcS5iaW5kKG1ldGhvZCksIGVuZHBvaW50KTtcbiAgICB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuc3VwcGxlbWVudCA9IGZ1bmN0aW9uIChmbiwgZW5kcG9pbnQpIHtcbiAgICAgICAgaWYgKGVuZHBvaW50LnN1YnN0cmluZygwLCAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW5kcG9pbnQgbXVzdCBzdGFydCB3aXRoIGxlYWRpbmcgc2xhc2gnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxID0gZm4odGhpcy5iYXNlVXJsICsgZW5kcG9pbnQpO1xuICAgICAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgICAgICAgcmVxLnNldCgnQXV0aG9yaXphdGlvbicsIFwiQmVhcmVyIFwiICsgdGhpcy50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuICAgIHJldHVybiBDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpZygpIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMgPSB7XG4gICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBwcy5pb25pYy5pbycsXG4gICAgICAgICAgICAncHVzaCc6ICdodHRwczovL3B1c2guaW9uaWMuaW8nLFxuICAgICAgICAgICAgJ2FuYWx5dGljcyc6ICdodHRwczovL2FuYWx5dGljcy5pb25pYy5pbycsXG4gICAgICAgICAgICAnZGVwbG95JzogJ2h0dHBzOi8vYXBwcy5pb25pYy5pbycsXG4gICAgICAgICAgICAncGxhdGZvcm0tYXBpJzogJ2h0dHBzOi8vYXBpLmlvbmljLmlvJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBDb25maWcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9O1xuICAgIENvbmZpZy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzW25hbWVdO1xuICAgIH07XG4gICAgQ29uZmlnLnByb3RvdHlwZS5nZXRVUkwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZGV2TG9jYXRpb25zID0gdGhpcy5zZXR0aW5ncyAmJiB0aGlzLnNldHRpbmdzWydkZXZfbG9jYXRpb25zJ10gfHwge307XG4gICAgICAgIGlmIChkZXZMb2NhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBkZXZMb2NhdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25zW25hbWVdO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmZpZztcbn0oKSk7XG5leHBvcnRzLkNvbmZpZyA9IENvbmZpZztcbmV4cG9ydHMuY29uZmlnID0gbmV3IENvbmZpZygpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ29yZG92YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29yZG92YShkZXZpY2UsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgQ29yZG92YS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHZhciBjb3Jkb3ZhU2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICB2YXIgY29yZG92YVNyYyA9ICdjb3Jkb3ZhLmpzJztcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kZXZpY2UuZGV2aWNlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZHJvaWQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuc3Vic3RyaW5nKDAsIDQpID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmRvdmFTcmMgPSAnZmlsZTovLy9hbmRyb2lkX2Fzc2V0L3d3dy9jb3Jkb3ZhLmpzJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpcGFkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcGhvbmUnOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvY29yZG92YV9qc19ib290c3RyYXBfcmVzb3VyY2U9KC4qPykoJnwjfCQpL2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZG92YVNyYyA9IGRlY29kZVVSSShyZXNvdXJjZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0lvbmljIENvcmRvdmE6IGNvdWxkIG5vdCBmaW5kIGNvcmRvdmFfanNfYm9vdHN0cmFwX3Jlc291cmNlIHF1ZXJ5IHBhcmFtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBDb3Jkb3ZhOicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29yZG92YVNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGNvcmRvdmFTcmMpO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjb3Jkb3ZhU2NyaXB0KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0lvbmljIENvcmRvdmE6IGluamVjdGluZyBjb3Jkb3ZhLmpzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvcmRvdmEucHJvdG90eXBlLmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBDb3Jkb3ZhOiBzZWFyY2hpbmcgZm9yIGNvcmRvdmEuanMnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb3Jkb3ZhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnSW9uaWMgQ29yZG92YTogY29yZG92YS5qcyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgIHZhciBsZW4gPSBzY3JpcHRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV0uZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzY3JpcHQuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHNMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzTGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbcGFydHNMZW5ndGggLSAxXSA9PT0gJ2NvcmRvdmEuanMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBDb3Jkb3ZhOiBjb3Jkb3ZhLmpzIGhhcyBwcmV2aW91c2x5IGJlZW4gaW5jbHVkZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBDb3Jkb3ZhOiBlbmNvdW50ZXJlZCBlcnJvciB3aGlsZSB0ZXN0aW5nIGZvciBjb3Jkb3ZhLmpzIHByZXNlbmNlLCAnICsgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIENvcmRvdmE7XG59KCkpO1xuZXhwb3J0cy5Db3Jkb3ZhID0gQ29yZG92YTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNsaWVudF8xID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcbnZhciBjb3Jkb3ZhXzEgPSByZXF1aXJlKCcuL2NvcmRvdmEnKTtcbnZhciBkZXZpY2VfMSA9IHJlcXVpcmUoJy4vZGV2aWNlJyk7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xudmFyIHN0b3JhZ2VfMSA9IHJlcXVpcmUoJy4vc3RvcmFnZScpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbnZhciBjb25maWdfMSA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgQ29yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29yZSgpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9ICcwLjguMC1iZXRhLjcnO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ18xLmNvbmZpZztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKCk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IGNsaWVudF8xLkNsaWVudCh0aGlzLmNvbmZpZy5nZXRVUkwoJ3BsYXRmb3JtLWFwaScpKTtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSBuZXcgZGV2aWNlXzEuRGV2aWNlKCk7XG4gICAgICAgIHRoaXMuY29yZG92YSA9IG5ldyBjb3Jkb3ZhXzEuQ29yZG92YSh0aGlzLmRldmljZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBzdG9yYWdlXzEuU3RvcmFnZSgpO1xuICAgICAgICB0aGlzLmNvcmRvdmEubG9hZCgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRIYW5kbGVycygpO1xuICAgIH1cbiAgICBDb3JlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGNmZykge1xuICAgICAgICB0aGlzLmNvbmZpZy5yZWdpc3RlcihjZmcpO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBDb3JlOiBpbml0Jyk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KCdjb3JlOmluaXQnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlLnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29yZS5wcm90b3R5cGUucmVnaXN0ZXJFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIub24oJ2F1dGg6dG9rZW4tY2hhbmdlZCcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGllbnQudG9rZW4gPSBkYXRhWyduZXcnXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5vbignY29yZTppbml0JywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLmNsaWVudC5iYXNlVXJsID0gX3RoaXMuY29uZmlnLmdldFVSTCgncGxhdGZvcm0tYXBpJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kZXZpY2UuZGV2aWNlVHlwZSA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBDb3JlOiBhdHRlbXB0aW5nIHRvIG1vY2sgcGx1Z2lucycpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoJ2RldmljZTpyZWFkeScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oJ0lvbmljIENvcmU6IHBsdWdpbnMgYXJlIHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoJ2RldmljZTpyZWFkeScpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXJlIGEgY2FsbGJhY2sgd2hlbiBjb3JlICsgcGx1Z2lucyBhcmUgcmVhZHkuIFRoaXMgd2lsbCBmaXJlIGltbWVkaWF0ZWx5IGlmXG4gICAgICogdGhlIGNvbXBvbmVudHMgaGF2ZSBhbHJlYWR5IGJlY29tZSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9mZlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wbHVnaW5zUmVhZHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLm9uKCdkZXZpY2U6cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb3JlO1xufSgpKTtcbmV4cG9ydHMuQ29yZSA9IENvcmU7XG5leHBvcnRzLklvbmljUGxhdGZvcm0gPSBuZXcgQ29yZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGF0YVR5cGVNYXBwaW5nID0ge307XG52YXIgRGF0YVR5cGVTY2hlbWEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFUeXBlU2NoZW1hKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgRGF0YVR5cGVTY2hlbWEucHJvdG90eXBlLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgeCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3hdID0gcHJvcGVydGllc1t4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0YVR5cGVTY2hlbWEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnX19Jb25pY19EYXRhVHlwZVNjaGVtYSc6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICd2YWx1ZSc6IGRhdGEudmFsdWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIERhdGFUeXBlU2NoZW1hLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLm5hbWUgJiYgdGhpcy5kYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YVR5cGVTY2hlbWE7XG59KCkpO1xuZXhwb3J0cy5EYXRhVHlwZVNjaGVtYSA9IERhdGFUeXBlU2NoZW1hO1xudmFyIERhdGFUeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhVHlwZSgpIHtcbiAgICB9XG4gICAgRGF0YVR5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChkYXRhVHlwZU1hcHBpbmdbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGF0YVR5cGVNYXBwaW5nW25hbWVdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBEYXRhVHlwZS5nZXRNYXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGF0YVR5cGVNYXBwaW5nO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUeXBlLCBcIlNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGFUeXBlU2NoZW1hO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEYXRhVHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChuYW1lLCBjbHMpIHtcbiAgICAgICAgZGF0YVR5cGVNYXBwaW5nW25hbWVdID0gY2xzO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFUeXBlO1xufSgpKTtcbmV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZTtcbnZhciBVbmlxdWVBcnJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5pcXVlQXJyYXkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHZhbHVlW3hdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBVbmlxdWVBcnJheS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIHNjaGVtYSA9IG5ldyBEYXRhVHlwZVNjaGVtYSh7ICduYW1lJzogJ1VuaXF1ZUFycmF5JywgJ3ZhbHVlJzogZGF0YSB9KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS50b0pTT04oKTtcbiAgICB9O1xuICAgIFVuaXF1ZUFycmF5LmZyb21TdG9yYWdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pcXVlQXJyYXkodmFsdWUpO1xuICAgIH07XG4gICAgVW5pcXVlQXJyYXkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVW5pcXVlQXJyYXkucHJvdG90eXBlLnB1bGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5kYXRhLmluZGV4T2YodmFsdWUpO1xuICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICAgIHJldHVybiBVbmlxdWVBcnJheTtcbn0oKSk7XG5leHBvcnRzLlVuaXF1ZUFycmF5ID0gVW5pcXVlQXJyYXk7XG5EYXRhVHlwZS5yZWdpc3RlcignVW5pcXVlQXJyYXknLCBVbmlxdWVBcnJheSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBEZXZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldmljZSgpIHtcbiAgICAgICAgdGhpcy5kZXZpY2VUeXBlID0gdGhpcy5kZXRlcm1pbmVEZXZpY2VUeXBlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBkZXZpY2UgaXMgYW4gQW5kcm9pZCBkZXZpY2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIEFuZHJvaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuaXNBbmRyb2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXZpY2VUeXBlID09PSAnYW5kcm9pZCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZGV2aWNlIGlzIGFuIGlPUyBkZXZpY2VcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGlPUywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5pc0lPUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlVHlwZSA9PT0gJ2lwaG9uZScgfHwgdGhpcy5kZXZpY2VUeXBlID09PSAnaXBhZCc7XG4gICAgfTtcbiAgICBEZXZpY2UucHJvdG90eXBlLmlzQ29ubmVjdGVkVG9OZXR3b3JrID0gZnVuY3Rpb24gKHN0cmljdE1vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJpY3RNb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3RyaWN0TW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmNvbm5lY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgbmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBDb25uZWN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKCFzdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChuYXZpZ2F0b3IuY29ubmVjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rpb24uRVRIRVJORVQ6XG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rpb24uV0lGSTpcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdGlvbi5DRUxMXzJHOlxuICAgICAgICAgICAgY2FzZSBDb25uZWN0aW9uLkNFTExfM0c6XG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rpb24uQ0VMTF80RzpcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdGlvbi5DRUxMOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGV2aWNlIHR5cGUgdmlhIHRoZSB1c2VyIGFnZW50IHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gbmFtZSBvZiBkZXZpY2UgcGxhdGZvcm0gb3IgJ3Vua25vd24nIGlmIHVuYWJsZSB0byBpZGVudGlmeSB0aGUgZGV2aWNlXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5kZXRlcm1pbmVEZXZpY2VUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICB2YXIgaXBhZCA9IGFnZW50Lm1hdGNoKC9pUGFkL2kpO1xuICAgICAgICBpZiAoaXBhZCAmJiAoaXBhZFswXS50b0xvd2VyQ2FzZSgpID09PSAnaXBhZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lwYWQnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpcGhvbmUgPSBhZ2VudC5tYXRjaCgvaVBob25lL2kpO1xuICAgICAgICBpZiAoaXBob25lICYmIChpcGhvbmVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2lwaG9uZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lwaG9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuZHJvaWQgPSBhZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcbiAgICAgICAgaWYgKGFuZHJvaWQgJiYgKGFuZHJvaWRbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2FuZHJvaWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdhbmRyb2lkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgIH07XG4gICAgcmV0dXJuIERldmljZTtcbn0oKSk7XG5leHBvcnRzLkRldmljZSA9IERldmljZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICB9XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0gbnVsbDsgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfYVtfaV07XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vYXBwJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9jb3JlJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9kYXRhLXR5cGVzJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9ldmVudHMnKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL2xvZ2dlcicpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vcHJvbWlzZScpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vcmVxdWVzdCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vY29uZmlnJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9zdG9yYWdlJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi91c2VyJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9jbGllbnQnKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICAgICAgdGhpcy5zaWxlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRmbiA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuZXJyZm4gPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG4gICAgfVxuICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5vdXRmbi5hcHBseSh0aGlzLCBbbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5vdXRmbi5hcHBseSh0aGlzLCBbbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgb3B0aW9uYWxQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyZm4uYXBwbHkodGhpcywgW21lc3NhZ2VdLmNvbmNhdChvcHRpb25hbFBhcmFtcykpO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgUHJvbWlzZVdpdGhOb3RpZnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9taXNlV2l0aE5vdGlmeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9taXNlV2l0aE5vdGlmeSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByb21pc2VXaXRoTm90aWZ5LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvbk5vdGlmaWVkKSB7XG4gICAgICAgIHRoaXMub25Ob3RpZnkgPSBvbk5vdGlmaWVkO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcywgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2VXaXRoTm90aWZ5O1xufShQcm9taXNlKSk7XG5leHBvcnRzLlByb21pc2VXaXRoTm90aWZ5ID0gUHJvbWlzZVdpdGhOb3RpZnk7XG52YXIgRGVmZXJyZWRQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZlcnJlZFByb21pc2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubm90aWZ5VmFsdWVzID0gW107XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlV2l0aE5vdGlmeShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvcmlnaW5hbFRoZW4gPSB0aGlzLnByb21pc2UudGhlbjtcbiAgICAgICAgdGhpcy5wcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob2ssIGZhaWwsIG5vdGlmeSkge1xuICAgICAgICAgICAgX3RoaXMuX25vdGlmeSA9IG5vdGlmeTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5ub3RpZnlWYWx1ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgX3RoaXMuX25vdGlmeSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFRoZW4uY2FsbChfdGhpcy5wcm9taXNlLCBvaywgZmFpbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIERlZmVycmVkUHJvbWlzZS5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fbm90aWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlcnJlZFByb21pc2U7XG59KCkpO1xuZXhwb3J0cy5EZWZlcnJlZFByb21pc2UgPSBEZWZlcnJlZFByb21pc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcbnZhciBhdXRoXzEgPSByZXF1aXJlKCcuLi9hdXRoL2F1dGgnKTtcbnZhciByID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xuZnVuY3Rpb24gcmVxdWVzdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgdmFyIHRva2VuID0gYXV0aF8xLkF1dGguZ2V0VXNlclRva2VuKCk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmVhcmVyICcgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVxdWVzdEluZm8gPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgdmFyIHJlcXVlc3RfbWV0aG9kID0gKG9wdGlvbnMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciByZXEgPSByW3JlcXVlc3RfbWV0aG9kXShvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybCk7XG4gICAgaWYgKG9wdGlvbnMuanNvbikge1xuICAgICAgICByZXEgPSByZXEuc2VuZChvcHRpb25zLmpzb24pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHJlcSA9IHJlcS5zZXQob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxID0gcmVxLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgcmVxdWVzdEluZm8uX2xhc3RFcnJvciA9IGVycjtcbiAgICAgICAgcmVxdWVzdEluZm8uX2xhc3RSZXN1bHQgPSByZXM7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHAucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA8IDIwMCB8fCByZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgICAgIHZhciBfZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IEZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlIG9mICcgKyByZXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBwLnJlamVjdCh7ICdyZXNwb25zZSc6IHJlcywgJ2Vycm9yJzogX2VyciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAucmVzb2x2ZSh7ICdyZXNwb25zZSc6IHJlcywgJ3BheWxvYWQnOiByZXMuYm9keSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHAucmVxdWVzdEluZm8gPSByZXF1ZXN0SW5mbztcbiAgICByZXR1cm4gcC5wcm9taXNlO1xufVxuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb21pc2VfMSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xudmFyIExvY2FsU3RvcmFnZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbFN0b3JhZ2VTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgTG9jYWxTdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfTtcbiAgICBMb2NhbFN0b3JhZ2VTdHJhdGVneS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9O1xuICAgIExvY2FsU3RvcmFnZVN0cmF0ZWd5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxTdG9yYWdlU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VTdHJhdGVneSA9IExvY2FsU3RvcmFnZVN0cmF0ZWd5O1xudmFyIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3koKSB7XG4gICAgfVxuICAgIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9O1xuICAgIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9O1xuICAgIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5TZXNzaW9uU3RvcmFnZVN0cmF0ZWd5ID0gU2Vzc2lvblN0b3JhZ2VTdHJhdGVneTtcbnZhciBvYmplY3RDYWNoZSA9IHt9O1xudmFyIG1lbW9yeUxvY2tzID0ge307XG52YXIgU3RvcmFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmFnZSgpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IG5ldyBMb2NhbFN0b3JhZ2VTdHJhdGVneSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgYW4gb2JqZWN0IGluIGxvY2FsIHN0b3JhZ2UgdW5kZXIgdGhlIGdpdmVuIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgTmFtZSBvZiB0aGUga2V5IHRvIHN0b3JlIHZhbHVlcyBpblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzdG9yZSB3aXRoIHRoZSBrZXlcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLnN0b3JlT2JqZWN0ID0gZnVuY3Rpb24gKGtleSwgb2JqZWN0KSB7XG4gICAgICAgIC8vIENvbnZlcnQgb2JqZWN0IHRvIEpTT04gYW5kIHN0b3JlIGluIGxvY2FsU3RvcmFnZVxuICAgICAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kuc2V0KGtleSwganNvbik7XG4gICAgICAgIC8vIFRoZW4gc3RvcmUgaXQgaW4gdGhlIG9iamVjdCBjYWNoZVxuICAgICAgICBvYmplY3RDYWNoZVtrZXldID0gb2JqZWN0O1xuICAgIH07XG4gICAgU3RvcmFnZS5wcm90b3R5cGUuZGVsZXRlT2JqZWN0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5LnJlbW92ZShrZXkpO1xuICAgICAgICBkZWxldGUgb2JqZWN0Q2FjaGVba2V5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVpdGhlciByZXRyaWV2ZXMgdGhlIGNhY2hlZCBjb3B5IG9mIGFuIG9iamVjdCxcbiAgICAgKiBvciB0aGUgb2JqZWN0IGl0c2VsZiBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcHVsbCBmcm9tXG4gICAgICogQHJldHVybiB7bWl4ZWR9IFJldHVybnMgdGhlIHByZXZpb3VzbHkgc3RvcmVkIE9iamVjdCBvciBudWxsXG4gICAgICovXG4gICAgU3RvcmFnZS5wcm90b3R5cGUucmV0cmlldmVPYmplY3QgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiBpdCdzIHRoZSBvYmplY3QgY2FjaGVcbiAgICAgICAgdmFyIGNhY2hlZCA9IG9iamVjdENhY2hlW2tleV07XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVzZXJpYWxpemUgdGhlIG9iamVjdCBmcm9tIEpTT05cbiAgICAgICAgdmFyIGpzb24gPSB0aGlzLnN0cmF0ZWd5LmdldChrZXkpO1xuICAgICAgICAvLyBudWxsIG9yIHVuZGVmaW5lZCAtLT4gcmV0dXJuIG51bGwuXG4gICAgICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvY2tzIHRoZSBhc3luYyBjYWxsIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBwcm9taXNlIGFuZCBsb2NrIGtleS5cbiAgICAgKiBPbmx5IG9uZSBhc3luY0Z1bmN0aW9uIGdpdmVuIGJ5IHRoZSBsb2NrS2V5IGNhbiBiZSBydW5uaW5nIGF0IGFueSB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2tLZXkgc2hvdWxkIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGlzIGFzeW5jIGNhbGwuXG4gICAgICogICAgICAgIFRoaXMgaXMgcmVxdWlyZWQgZm9yIHBlcnNpc3RlbmNlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGFzeW5jRnVuY3Rpb24gUmV0dXJucyBhIHByb21pc2Ugb2YgdGhlIGFzeW5jIGNhbGwuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgbmV3IHByb21pc2UsIGlkZW50aWNhbCB0byB0aGUgb25lIHJldHVybmVkIGJ5IGFzeW5jRnVuY3Rpb24sXG4gICAgICogICAgICAgICAgYnV0IHdpdGggdHdvIG5ldyBlcnJvcnM6ICdpbl9wcm9ncmVzcycsIGFuZCAnbGFzdF9jYWxsX2ludGVycnVwdGVkJy5cbiAgICAgKi9cbiAgICBTdG9yYWdlLnByb3RvdHlwZS5sb2NrZWRBc3luY0NhbGwgPSBmdW5jdGlvbiAobG9ja0tleSwgYXN5bmNGdW5jdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIC8vIElmIHRoZSBtZW1vcnkgbG9jayBpcyBzZXQsIGVycm9yIG91dC5cbiAgICAgICAgaWYgKG1lbW9yeUxvY2tzW2xvY2tLZXldKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ2luX3Byb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHN0b3JlZCBsb2NrIGJ1dCBubyBtZW1vcnkgbG9jaywgZmxhZyBhIHBlcnNpc3RlbmNlIGVycm9yXG4gICAgICAgIGlmICh0aGlzLnN0cmF0ZWd5LmdldChsb2NrS2V5KSA9PT0gJ2xvY2tlZCcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgnbGFzdF9jYWxsX2ludGVycnVwdGVkJyk7XG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlLnRoZW4obnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RyYXRlZ3kucmVtb3ZlKGxvY2tLZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgc3RvcmVkIGFuZCBtZW1vcnkgbG9ja3NcbiAgICAgICAgbWVtb3J5TG9ja3NbbG9ja0tleV0gPSB0cnVlO1xuICAgICAgICBzZWxmLnN0cmF0ZWd5LnNldChsb2NrS2V5LCAnbG9ja2VkJyk7XG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGFzeW5jIG9wZXJhdGlvblxuICAgICAgICBhc3luY0Z1bmN0aW9uKCkudGhlbihmdW5jdGlvbiAoc3VjY2Vzc0RhdGEpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc3VjY2Vzc0RhdGEpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBhbmQgbWVtb3J5IGxvY2tzXG4gICAgICAgICAgICBkZWxldGUgbWVtb3J5TG9ja3NbbG9ja0tleV07XG4gICAgICAgICAgICBzZWxmLnN0cmF0ZWd5LnJlbW92ZShsb2NrS2V5KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yRGF0YSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yRGF0YSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGFuZCBtZW1vcnkgbG9ja3NcbiAgICAgICAgICAgIGRlbGV0ZSBtZW1vcnlMb2Nrc1tsb2NrS2V5XTtcbiAgICAgICAgICAgIHNlbGYuc3RyYXRlZ3kucmVtb3ZlKGxvY2tLZXkpO1xuICAgICAgICB9LCBmdW5jdGlvbiAobm90aWZ5RGF0YSkge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KG5vdGlmeURhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmFnZTtcbn0oKSk7XG5leHBvcnRzLlN0b3JhZ2UgPSBTdG9yYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXV0aF8xID0gcmVxdWlyZSgnLi4vYXV0aC9hdXRoJyk7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgc3RvcmFnZV8xID0gcmVxdWlyZSgnLi9zdG9yYWdlJyk7XG52YXIgZGF0YV90eXBlc18xID0gcmVxdWlyZSgnLi9kYXRhLXR5cGVzJyk7XG52YXIgQXBwVXNlckNvbnRleHQgPSBudWxsO1xudmFyIHN0b3JhZ2UgPSBuZXcgc3RvcmFnZV8xLlN0b3JhZ2UoKTtcbnZhciBVc2VyQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXNlckNvbnRleHQoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ29udGV4dCwgXCJsYWJlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdpb25pY19pb191c2VyXycgKyBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcHBfaWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVXNlckNvbnRleHQuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9yYWdlLmRlbGV0ZU9iamVjdChVc2VyQ29udGV4dC5sYWJlbCk7XG4gICAgfTtcbiAgICBVc2VyQ29udGV4dC5zdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFVzZXJDb250ZXh0LmdldFJhd0RhdGEoKSkge1xuICAgICAgICAgICAgVXNlckNvbnRleHQuc3RvcmVMZWdhY3lEYXRhKFVzZXJDb250ZXh0LmdldFJhd0RhdGEoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVzZXIuY3VycmVudCgpLmRhdGEuZGF0YS5fX2lvbmljX3VzZXJfbWlncmF0ZWQpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc3RvcmVPYmplY3QoVXNlckNvbnRleHQubGFiZWwgKyAnX2xlZ2FjeScsIHsgJ19faW9uaWNfdXNlcl9taWdyYXRlZCc6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zdG9yZU9iamVjdChVc2VyQ29udGV4dC5sYWJlbCwgVXNlci5jdXJyZW50KCkpO1xuICAgIH07XG4gICAgVXNlckNvbnRleHQuc3RvcmVMZWdhY3lEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFVc2VyQ29udGV4dC5nZXRSYXdMZWdhY3lEYXRhKCkpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc3RvcmVPYmplY3QoVXNlckNvbnRleHQubGFiZWwgKyAnX2xlZ2FjeScsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVc2VyQ29udGV4dC5nZXRSYXdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RvcmFnZS5yZXRyaWV2ZU9iamVjdChVc2VyQ29udGV4dC5sYWJlbCkgfHwgZmFsc2U7XG4gICAgfTtcbiAgICBVc2VyQ29udGV4dC5nZXRSYXdMZWdhY3lEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RvcmFnZS5yZXRyaWV2ZU9iamVjdChVc2VyQ29udGV4dC5sYWJlbCArICdfbGVnYWN5JykgfHwgZmFsc2U7XG4gICAgfTtcbiAgICBVc2VyQ29udGV4dC5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHN0b3JhZ2UucmV0cmlldmVPYmplY3QoVXNlckNvbnRleHQubGFiZWwpIHx8IGZhbHNlO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgVXNlckNvbnRleHQuc3RvcmVMZWdhY3lEYXRhKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIFVzZXIuZnJvbUNvbnRleHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgcmV0dXJuIFVzZXJDb250ZXh0O1xufSgpKTtcbnZhciBVc2VyRGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXNlckRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZXJEYXRhVHlwZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBVc2VyRGF0YS5wcm90b3R5cGUuZGVzZXJpYWxpemVyRGF0YVR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB4IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBvYmplY3QsIGxldCdzIGNoZWNrIGZvciBjdXN0b20gZGF0YSB0eXBlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGFbeF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gd2UgaGF2ZSBhIGN1c3RvbSB0eXBlP1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbeF0uX19Jb25pY19EYXRhVHlwZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZGF0YVt4XS5fX0lvbmljX0RhdGFUeXBlU2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGluZyA9IGRhdGFfdHlwZXNfMS5EYXRhVHlwZS5nZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgY3VzdG9tIHR5cGUgYW5kIGEgcmVnaXN0ZXJlZCBjbGFzcywgZ2l2ZSB0aGUgY3VzdG9tIGRhdGEgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbeF0gPSBtYXBwaW5nW25hbWVdLmZyb21TdG9yYWdlKHRoaXMuZGF0YVt4XS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVzZXJEYXRhLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgVXNlckRhdGEucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XG4gICAgfTtcbiAgICBVc2VyRGF0YS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gMCB8fCBkZWZhdWx0VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFVzZXJEYXRhO1xufSgpKTtcbmV4cG9ydHMuVXNlckRhdGEgPSBVc2VyRGF0YTtcbnZhciBVc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVc2VyKCkge1xuICAgICAgICB0aGlzLl9ibG9ja0xvYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmxvY2tTYXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Jsb2NrRGVsZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZyZXNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdW5zZXQgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVzZXJEYXRhKCk7XG4gICAgfVxuICAgIFVzZXIucHJvdG90eXBlLmlzRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLmlzQW5vbnltb3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVc2VyLnByb3RvdHlwZS5pc0F1dGhlbnRpY2F0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBVc2VyLmN1cnJlbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhfMS5BdXRoLmlzQXV0aGVudGljYXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFVzZXIuY3VycmVudCA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIGlmICghQXBwVXNlckNvbnRleHQpIHtcbiAgICAgICAgICAgIEFwcFVzZXJDb250ZXh0ID0gVXNlckNvbnRleHQubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXBwVXNlckNvbnRleHQpIHtcbiAgICAgICAgICAgIEFwcFVzZXJDb250ZXh0ID0gbmV3IFVzZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgQXBwVXNlckNvbnRleHQuaWQgPSB1c2VyLmlkO1xuICAgICAgICAgICAgQXBwVXNlckNvbnRleHQuZGF0YSA9IHVzZXIuZGF0YTtcbiAgICAgICAgICAgIEFwcFVzZXJDb250ZXh0LmRldGFpbHMgPSB1c2VyLmRldGFpbHM7XG4gICAgICAgICAgICBBcHBVc2VyQ29udGV4dC5fZnJlc2ggPSB1c2VyLl9mcmVzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXBwVXNlckNvbnRleHQ7XG4gICAgfTtcbiAgICBVc2VyLmZyb21Db250ZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBuZXcgVXNlcigpO1xuICAgICAgICB1c2VyLmlkID0gZGF0YS5faWQ7XG4gICAgICAgIHVzZXIuZGF0YSA9IG5ldyBVc2VyRGF0YShkYXRhLmRhdGEuZGF0YSk7XG4gICAgICAgIHVzZXIuZGV0YWlscyA9IGRhdGEuZGV0YWlscyB8fCB7fTtcbiAgICAgICAgdXNlci5fZnJlc2ggPSBkYXRhLl9mcmVzaDtcbiAgICAgICAgdXNlci5fZGlydHkgPSBkYXRhLl9kaXJ0eTtcbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfTtcbiAgICBVc2VyLnNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHZhciB0ZW1wVXNlciA9IG5ldyBVc2VyKCk7XG4gICAgICAgIGlmICghdGVtcFVzZXIuX2Jsb2NrTG9hZCkge1xuICAgICAgICAgICAgdGVtcFVzZXIuX2Jsb2NrTG9hZCA9IHRydWU7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jbGllbnQuZ2V0KCcvYXV0aC91c2Vycy9zZWxmJylcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFVzZXIuX2Jsb2NrTG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIFVzZXI6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wVXNlci5fYmxvY2tMb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBVc2VyOiBsb2FkZWQgdXNlcicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGN1c3RvbSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRlbXBVc2VyLmlkID0gcmVzLmJvZHkuZGF0YS51dWlkO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wVXNlci5kYXRhID0gbmV3IFVzZXJEYXRhKHJlcy5ib2R5LmRhdGEuY3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFVzZXIuZGV0YWlscyA9IHJlcy5ib2R5LmRhdGEuZGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgdGVtcFVzZXIuX2ZyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIFVzZXIuY3VycmVudCh0ZW1wVXNlcik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoVXNlci5jdXJyZW50KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFVzZXI6IGEgbG9hZCBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgJyArIHRoaXMgKyAnLicpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIFVzZXIubG9hZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB2YXIgdGVtcFVzZXIgPSBuZXcgVXNlcigpO1xuICAgICAgICB0ZW1wVXNlci5pZCA9IGlkO1xuICAgICAgICBpZiAoIXRlbXBVc2VyLl9ibG9ja0xvYWQpIHtcbiAgICAgICAgICAgIHRlbXBVc2VyLl9ibG9ja0xvYWQgPSB0cnVlO1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0uY2xpZW50LmdldChcIi9hdXRoL3VzZXJzL1wiICsgdGVtcFVzZXIuaWQpXG4gICAgICAgICAgICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBVc2VyLl9ibG9ja0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmVycm9yKCdJb25pYyBVc2VyOicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFVzZXIuX2Jsb2NrTG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgVXNlcjogbG9hZGVkIHVzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjdXN0b20gZGF0YVxuICAgICAgICAgICAgICAgICAgICB0ZW1wVXNlci5kYXRhID0gbmV3IFVzZXJEYXRhKHJlcy5ib2R5LmRhdGEuY3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFVzZXIuZGV0YWlscyA9IHJlcy5ib2R5LmRhdGEuZGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgdGVtcFVzZXIuX2ZyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodGVtcFVzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFVzZXI6IGEgbG9hZCBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgJyArIHRoaXMgKyAnLicpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVXNlci5jdXJyZW50KG5ldyBVc2VyKCkpO1xuICAgIH07XG4gICAgVXNlci5wcm90b3R5cGUuaXNGcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZXNoO1xuICAgIH07XG4gICAgVXNlci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLmdldEFQSUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFwaUZvcm1hdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kZXRhaWxzKSB7XG4gICAgICAgICAgICBhcGlGb3JtYXRba2V5XSA9IHRoaXMuZGV0YWlsc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGFwaUZvcm1hdC5jdXN0b20gPSB0aGlzLmRhdGEuZGF0YTtcbiAgICAgICAgcmV0dXJuIGFwaUZvcm1hdDtcbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLmdldEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlICdhcGktc2F2ZSc6XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gdGhpcy5nZXRBUElGb3JtYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkO1xuICAgIH07XG4gICAgVXNlci5wcm90b3R5cGUubWlncmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJhd0RhdGEgPSBVc2VyQ29udGV4dC5nZXRSYXdMZWdhY3lEYXRhKCk7XG4gICAgICAgIGlmIChyYXdEYXRhKSB7XG4gICAgICAgICAgICBpZiAoIXJhd0RhdGEuX19pb25pY191c2VyX21pZ3JhdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRVc2VyID0gSW9uaWMuVXNlci5jdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhID0gbmV3IFVzZXJEYXRhKHJhd0RhdGEuZGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXNlckRhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlci5zZXQoa2V5LCB1c2VyRGF0YS5kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50VXNlci5zZXQoJ19faW9uaWNfdXNlcl9taWdyYXRlZCcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBVc2VyLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ibG9ja0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrRGVsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxldGUoKTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jbGllbnQuZGVsZXRlKFwiL2F1dGgvdXNlcnMvXCIgKyB0aGlzLmlkKVxuICAgICAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tEZWxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgVXNlcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tEZWxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBVc2VyOiBkZWxldGVkICcgKyBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBVc2VyOiBhIGRlbGV0ZSBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBmb3IgJyArIHRoaXMgKyAnLicpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgVXNlci5wcm90b3R5cGUuX3N0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyA9PT0gVXNlci5jdXJyZW50KCkpIHtcbiAgICAgICAgICAgIFVzZXJDb250ZXh0LnN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLl9kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBVc2VyLmN1cnJlbnQoKSkge1xuICAgICAgICAgICAgVXNlckNvbnRleHQuZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2tTYXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja1NhdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3RvcmUoKTtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNsaWVudC5wYXRjaChcIi9hdXRoL3VzZXJzL1wiICsgdGhpcy5pZClcbiAgICAgICAgICAgICAgICAuc2VuZCh0aGlzLmdldEZvcm1hdCgnYXBpLXNhdmUnKSlcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2NrU2F2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIFVzZXI6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0ZyZXNoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl91bnNldCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9mcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tTYXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBVc2VyOiBzYXZlZCB1c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBVc2VyOiBhIHNhdmUgb3BlcmF0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgZm9yICcgKyB0aGlzICsgJy4nKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICBVc2VyLnByb3RvdHlwZS5yZXNldFBhc3N3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jbGllbnQucG9zdChcIi9hdXRoL3VzZXJzL1wiICsgdGhpcy5pZCArIFwiL3Bhc3N3b3JkLXJlc2V0XCIpXG4gICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgVXNlcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFVzZXI6IHBhc3N3b3JkIHJlc2V0IGZvciB1c2VyJyk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlci5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZCB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IHY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFVzZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJzxJb25pY1VzZXIgW1xcJycgKyB0aGlzLmlkICsgJ1xcJ10+JztcbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91bnNldFtrZXldO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIFVzZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgfTtcbiAgICBVc2VyLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRba2V5XSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudW5zZXQoa2V5KTtcbiAgICB9O1xuICAgIHJldHVybiBVc2VyO1xufSgpKTtcbmV4cG9ydHMuVXNlciA9IFVzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuLi9jb3JlL3Byb21pc2UnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCcuLi9jb3JlL2NvcmUnKTtcbnZhciBOT19QTFVHSU4gPSAnSU9OSUNfREVQTE9ZX01JU1NJTkdfUExVR0lOJztcbnZhciBJTklUSUFMX0RFTEFZID0gMSAqIDUgKiAxMDAwO1xudmFyIFdBVENIX0lOVEVSVkFMID0gMSAqIDYwICogMTAwMDtcbnZhciBEZXBsb3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcGxveSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wbHVnaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jaGFubmVsVGFnID0gJ3Byb2R1Y3Rpb24nO1xuICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgRGVwbG95OiBpbml0Jyk7XG4gICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICBzZWxmLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmVtaXR0ZXIuZW1pdCgnZGVwbG95OnJlYWR5Jyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgRGVwbG95IFBsdWdpblxuICAgICAqXG4gICAgICogSWYgdGhlIHBsdWdpbiBoYXMgbm90IGJlZW4gc2V0IHlldCwgYXR0ZW1wdCB0byBmZXRjaCBpdCwgb3RoZXJ3aXNlIGxvZ1xuICAgICAqIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lvbmljRGVwbG95fSBSZXR1cm5zIHRoZSBwbHVnaW4gb3IgZmFsc2VcbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLl9nZXRQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wbHVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbHVnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBJb25pY0RlcGxveSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBEZXBsb3k6IHBsdWdpbiBpcyBub3QgaW5zdGFsbGVkIG9yIGhhcyBub3QgbG9hZGVkLiBIYXZlIHlvdSBydW4gYGlvbmljIHBsdWdpbiBhZGQgaW9uaWMtcGx1Z2luLWRlcGxveWAgeWV0PycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsdWdpbiA9IElvbmljRGVwbG95O1xuICAgICAgICByZXR1cm4gSW9uaWNEZXBsb3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBEZXBsb3kgUGx1Z2luXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vblJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9nZXRQbHVnaW4oKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3BsdWdpbi5pbml0KGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLCBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0VVJMKCdwbGF0Zm9ybS1hcGknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIHVwZGF0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFdpbGwgcmVzb2x2ZSB3aXRoIHRydWUgaWYgYW4gdXBkYXRlIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLiBBIHN0cmluZyBvclxuICAgICAqICAgZXJyb3Igd2lsbCBiZSBwYXNzZWQgdG8gcmVqZWN0KCkgaW4gdGhlIGV2ZW50IG9mIGEgZmFpbHVyZS5cbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMub25SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fZ2V0UGx1Z2luKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9wbHVnaW4uY2hlY2soY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksIHNlbGYuX2NoYW5uZWxUYWcsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIERlcGxveTogYW4gdXBkYXRlIGlzIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBEZXBsb3k6IG5vIHVwZGF0ZXMgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIERlcGxveTogZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgY2hlY2tpbmcgZm9yIHVwZGF0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChOT19QTFVHSU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbmQgYXZhaWxhYmxlIHVwZGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGV4dHJhY3QoKVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSB3aXRoIHRydWUvZmFsc2Ugb3IgdXNlXG4gICAgICogICAgbm90aWZ5IHRvIHVwZGF0ZSB0aGUgZG93bmxvYWQgcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGx1Z2luLmRvd25sb2FkKGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09ICd0cnVlJyAmJiByZXN1bHQgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIERlcGxveTogZG93bmxvYWQgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0ID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoTk9fUExVR0lOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCB0aGUgbGFzdCBkb3dubG9hZGVkIHVwZGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGEgZG93bmxvYWQoKSBzdWNjZXNzZnVsbHkgcmVzb2x2ZXMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIHdpdGggdHJ1ZS9mYWxzZSBvciB1c2VcbiAgICAgKiAgICAgICAgICAgICAgICAgICBub3RpZnkgdG8gdXBkYXRlIHRoZSBleHRyYWN0aW9uIHByb2dyZXNzLlxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGx1Z2luLmV4dHJhY3QoY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gJ2RvbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBEZXBsb3k6IGV4dHJhY3Rpb24gY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGxhdGVzdCBkZXBsb3llZCB2ZXJzaW9uXG4gICAgICogVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSB0byBjYWxsIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGRvd25sb2FkZWQgYW5kIGV4dHJhY3RlZFxuICAgICAqIGFuIHVwZGF0ZSBhbmQgd2lzaCB0byByZWxvYWQgdGhlIGFwcCB3aXRoIHRoZSBsYXRlc3QgZGVwbG95LiBUaGUgbGF0ZXN0IGRlcGxveVxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBiZSBsb2FkZWQgd2hlbiB0aGUgYXBwIGlzIHN0YXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGx1Z2luLnJlZGlyZWN0KGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYXRjaCBjb25zdGFudGx5IGNoZWNrcyBmb3IgdXBkYXRlcywgYW5kIHRyaWdnZXJzIGFuXG4gICAgICogZXZlbnQgd2hlbiBvbmUgaXMgcmVhZHkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgV2F0Y2ggY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGdldCBhIG5vdGlmeSgpIGNhbGxiYWNrIHdoZW4gYW4gdXBkYXRlIGlzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmluaXRpYWxEZWxheSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdHMuaW5pdGlhbERlbGF5ID0gSU5JVElBTF9ERUxBWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuaW50ZXJ2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRzLmludGVydmFsID0gV0FUQ0hfSU5URVJWQUw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICAgICAgc2VsZi5jaGVjaygpLnRoZW4oZnVuY3Rpb24gKGhhc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KGhhc1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBEZXBsb3k6IHVuYWJsZSB0byBjaGVjayBmb3IgdXBkYXRlczogJyArIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoZWNrIG91ciB0aW1lb3V0IHRvIG1ha2Ugc3VyZSBpdCB3YXNuJ3QgY2xlYXJlZCB3aGlsZSB3ZSB3ZXJlIHdhaXRpbmdcbiAgICAgICAgICAgIC8vIGZvciBhIHNlcnZlciByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrVGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2tGb3JVcGRhdGVzLmJpbmQoc2VsZiksIG9wdHMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGFmdGVyIGFuIGluaXRpYWwgc2hvcnQgZGVwbGF5XG4gICAgICAgIHRoaXMuX2NoZWNrVGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2tGb3JVcGRhdGVzLmJpbmQoc2VsZiksIG9wdHMuaW5pdGlhbERlbGF5KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIGF1dG9tYXRpY2FsbHkgbG9va2luZyBmb3IgdXBkYXRlc1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2hlY2tUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fY2hlY2tUaW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGRlcGxveVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlc29sdmVyIHdpbGwgYmUgcGFzc2VkIGFuIG9iamVjdCB0aGF0IGhhcyBrZXkvdmFsdWVcbiAgICAgKiAgICBwYWlycyBwZXJ0YWluaW5nIHRvIHRoZSBjdXJyZW50bHkgZGVwbG95ZWQgdXBkYXRlLlxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGx1Z2luLmluZm8oY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoTk9fUExVR0lOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgRGVwbG95IHZlcnNpb25zIHRoYXQgaGF2ZSBiZWVuIGluc3RhbGxlZCBvbiB0aGlzIGRldmljZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlc29sdmVyIHdpbGwgYmUgcGFzc2VkIGFuIGFycmF5IG9mIGRlcGxveSB1dWlkc1xuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuZ2V0VmVyc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vblJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9nZXRQbHVnaW4oKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3BsdWdpbi5nZXRWZXJzaW9ucyhjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jb25maWcuZ2V0KCdhcHBfaWQnKSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChOT19QTFVHSU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gaW5zdGFsbGVkIGRlcGxveSBvbiB0aGlzIGRldmljZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHV1aWQgVGhlIGRlcGxveSB1dWlkIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIHRoZSBkZXZpY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBTdGFuZGFyZCByZXNvbHZlL3JlamVjdCByZXNvbHV0aW9uXG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS5kZWxldGVWZXJzaW9uID0gZnVuY3Rpb24gKHV1aWQpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGx1Z2luLmRlbGV0ZVZlcnNpb24oY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksIHV1aWQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoTk9fUExVR0lOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbWV0YWRhdGEgZm9yIGEgZ2l2ZW4gZGVwbG95IHV1aWQuIElmIG5vIHV1aWQgaXMgZ2l2ZW4sIGl0IHdpbGwgYXR0ZW1wdFxuICAgICAqIHRvIGdyYWIgdGhlIG1ldGFkYXRhIGZvciB0aGUgbW9zdCByZWNlbnRseSBrbm93biB1cGRhdGUgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dWlkIFRoZSBkZXBsb3kgdXVpZCB5b3Ugd2lzaCB0byBncmFiIG1ldGFkYXRhIGZvciwgY2FuIGJlIGxlZnQgYmxhbmsgdG8gZ3JhYiBsYXRlc3Qga25vd24gdXBkYXRlIG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gU3RhbmRhcmQgcmVzb2x2ZS9yZWplY3QgcmVzb2x1dGlvblxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAodXVpZCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMub25SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fZ2V0UGx1Z2luKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9wbHVnaW4uZ2V0TWV0YWRhdGEoY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksIHV1aWQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQubWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoTk9fUExVR0lOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZXBsb3kgY2hhbm5lbCB0aGF0IHNob3VsZCBiZSBjaGVja2VkIGZvciB1cGRhdHNlXG4gICAgICogU2VlIGh0dHA6Ly9kb2NzLmlvbmljLmlvL2RvY3MvZGVwbG95LWNoYW5uZWxzIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFRhZyBUaGUgY2hhbm5lbCB0YWcgdG8gdXNlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoY2hhbm5lbFRhZykge1xuICAgICAgICB0aGlzLl9jaGFubmVsVGFnID0gY2hhbm5lbFRhZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhcHAgd2l0aCB0aGUgbGF0ZXN0IGRlcGxveVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVmZXJMb2FkIERlZmVyIGxvYWRpbmcgdGhlIGFwcGxpZWQgdXBkYXRlIGFmdGVyIHRoZSBpbnN0YWxsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UgcmVzdWx0XG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVmZXJMb2FkKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmVyTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmVyTG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlZmVyTG9hZGluZyA9IGRlZmVyTG9hZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBzZWxmLmNoZWNrKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSB1cGRhdGVzLCBkb3dubG9hZCB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRvd25sb2FkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdkb3dubG9hZCBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV4dHJhY3QoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgnZXh0cmFjdGlvbiBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVmZXJMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGx1Z2luLnJlZGlyZWN0KGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IGRvd25sb2FkUHJvZ3Jlc3MgKyAodXBkYXRlIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkUHJvZ3Jlc3MgPSAodXBkYXRlIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KGRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpcmUgYSBjYWxsYmFjayB3aGVuIGRlcGxveSBpcyByZWFkeS4gVGhpcyB3aWxsIGZpcmUgaW1tZWRpYXRlbHkgaWZcbiAgICAgKiBkZXBsb3kgaGFzIGFscmVhZHkgYmVjb21lIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb2ZmXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faXNSZWFkeSkge1xuICAgICAgICAgICAgY2FsbGJhY2soc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5lbWl0dGVyLm9uKCdkZXBsb3k6cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlcGxveTtcbn0oKSk7XG5leHBvcnRzLkRlcGxveSA9IERlcGxveTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGVwbG95JykpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi4vY29yZS9jb3JlJyk7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vY29yZS9wcm9taXNlJyk7XG52YXIgRW52aXJvbm1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEVudmlyb25tZW50IGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gRW52aXJvbm1lbnQoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgYW4gZW52aXJvbm1lbnQsIGNhbGxzIGxvYWRFbnZGcm9tQVBJXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIEVudmlyb25tZW50IHRhZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2VXaXRoTm90aWZ5fSB3aWxsIHJlc29sdmUvcmVqZWN0IHdpdGggdGhlIGNvbmZpZyBvYmplY3Qgb3IgZXJyb3JcbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdGhpcy5sb2FkRW52RnJvbUFQSSh0YWcpLnRoZW4oZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShlbnZbJ2NvbmZpZyddKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWQgYW4gZW52aXJvbm1lbnQgZnJvbSB0aGUgQVBJXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIEVudmlyb25tZW50IHRhZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2VXaXRoTm90aWZ5fSB3aWxsIHJlc29sdmUvcmVqZWN0IHdpdGggdGhlIGNvbmZpZyBvYmplY3Qgb3IgZXJyb3JcbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUubG9hZEVudkZyb21BUEkgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHZhciBhcHBJZCA9IGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpO1xuICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jbGllbnQuZ2V0KFwiL2FwcHMvXCIgKyBhcHBJZCArIFwiL2Vudi9cIiArIHRhZylcbiAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlcy5ib2R5LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRW52aXJvbm1lbnQ7XG59KCkpO1xuZXhwb3J0cy5FbnZpcm9ubWVudCA9IEVudmlyb25tZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuX19leHBvcnQocmVxdWlyZSgnLi9lbnZpcm9ubWVudHMnKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5fX2V4cG9ydChyZXF1aXJlKCcuL2FuYWx5dGljcy9pbmRleCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYXV0aC9pbmRleCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vY29yZS9pbmRleCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGVwbG95L2luZGV4JykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9pbnNpZ2h0cy9pbmRleCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZW52aXJvbm1lbnRzL2luZGV4JykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9wdXNoL2luZGV4JykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9saW5rcy9pbmRleCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vdXRpbC9pbmRleCcpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vaW5zaWdodHMnKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdGF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0KGFwcElkLCBzdGF0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLnN0YXQgPSBzdGF0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcbiAgICAgICAgdGhpcy5zdGF0ID0gc3RhdDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNyZWF0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBTdGF0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHBfaWQ6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICBzdGF0OiB0aGlzLnN0YXQsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWQ6IHRoaXMuY3JlYXRlZC50b0lTT1N0cmluZygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXQ7XG59KCkpO1xuZXhwb3J0cy5TdGF0ID0gU3RhdDtcbnZhciBJbnNpZ2h0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5zaWdodHMoY2xpZW50LCBhcHBJZCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLnN1Ym1pdENvdW50ID0gSW5zaWdodHMuU1VCTUlUX0NPVU5UO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLmJhdGNoID0gW107XG4gICAgfVxuICAgIEluc2lnaHRzLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChzdGF0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgdGhpcy50cmFja1N0YXQobmV3IFN0YXQodGhpcy5hcHBJZCwgc3RhdCwgdmFsdWUpKTtcbiAgICB9O1xuICAgIEluc2lnaHRzLnByb3RvdHlwZS50cmFja1N0YXQgPSBmdW5jdGlvbiAoc3RhdCkge1xuICAgICAgICB0aGlzLmJhdGNoLnB1c2goc3RhdCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFN1Ym1pdCgpKSB7XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnNpZ2h0cy5wcm90b3R5cGUuc2hvdWxkU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaC5sZW5ndGggPj0gdGhpcy5zdWJtaXRDb3VudDtcbiAgICB9O1xuICAgIEluc2lnaHRzLnByb3RvdHlwZS5zdWJtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnNpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5iYXRjaDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzdGF0ID0gX2FbX2ldO1xuICAgICAgICAgICAgaW5zaWdodHMucHVzaChzdGF0LnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucG9zdCgnL2luc2lnaHRzJylcbiAgICAgICAgICAgIC5zZW5kKHsgJ2luc2lnaHRzJzogaW5zaWdodHMgfSk7XG4gICAgfTtcbiAgICBJbnNpZ2h0cy5TVUJNSVRfQ09VTlQgPSAxMDA7XG4gICAgcmV0dXJuIEluc2lnaHRzO1xufSgpKTtcbmV4cG9ydHMuSW5zaWdodHMgPSBJbnNpZ2h0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vbGlua3MnKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBMaW5rcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua3MoY2xpZW50LCBhcHBJZCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgIH1cbiAgICBMaW5rcy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua3M7XG59KCkpO1xuZXhwb3J0cy5MaW5rcyA9IExpbmtzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuX19leHBvcnQocmVxdWlyZSgnLi9wdXNoLWRldicpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vcHVzaC1tZXNzYWdlJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9wdXNoLXRva2VuJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9wdXNoJykpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi4vY29yZS9jb3JlJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgcHVzaF90b2tlbl8xID0gcmVxdWlyZSgnLi9wdXNoLXRva2VuJyk7XG4vKipcbiAqIFB1c2hEZXYgU2VydmljZVxuICpcbiAqIFRoaXMgc2VydmljZSBhY3RzIGFzIGEgbW9jayBwdXNoIHNlcnZpY2UgdGhhdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIHByZS1zZXR1cCBvZlxuICogR0NNL0FQTlMgaW4gYW4gSW9uaWMuaW8gcHJvamVjdC5cbiAqXG4gKiBIb3cgaXQgd29ya3M6XG4gKlxuICogICBXaGVuIHJlZ2lzdGVyKCkgaXMgY2FsbGVkLCB0aGlzIHNlcnZpY2UgaXMgdXNlZCB0byBnZW5lcmF0ZSBhIHJhbmRvbVxuICogICBkZXZlbG9wbWVudCBkZXZpY2UgdG9rZW4uIFRoaXMgdG9rZW4gaXMgbm90IHZhbGlkIGZvciBhbnkgc2VydmljZSBvdXRzaWRlIG9mXG4gKiAgIElvbmljIFB1c2ggd2l0aCBgZGV2X3B1c2hgIHNldCB0byB0cnVlLiBUaGVzZSB0b2tlbnMgZG8gbm90IGxhc3QgbG9uZyBhbmQgYXJlIG5vdFxuICogICBlbGlnaWJsZSBmb3IgdXNlIGluIGEgcHJvZHVjdGlvbiBhcHAuXG4gKlxuICogICBUaGUgZGV2aWNlIHdpbGwgdGhlbiBwZXJpb2RpY2FsbHkgY2hlY2sgdGhlIFB1c2ggc2VydmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zIHNlbnRcbiAqICAgdG8gb3VyIGRldmVsb3BtZW50IHRva2VuIC0tIHNvIHVubGlrZSBhIHR5cGljYWwgXCJwdXNoXCIgdXBkYXRlLCB0aGlzIGFjdHVhbGx5IHVzZXNcbiAqICAgXCJwb2xsaW5nXCIgdG8gZmluZCBuZXcgbm90aWZpY2F0aW9ucy4gVGhpcyBtZWFucyB5b3UgKk1VU1QqIGhhdmUgdGhlIGFwcGxpY2F0aW9uIG9wZW5cbiAqICAgYW5kIGluIHRoZSBmb3JlZ3JvdW5kIHRvIHJldHJlaXZlIG1lc3NzYWdlcy5cbiAqXG4gKiAgIFRoZSBjYWxsYmFja3MgcHJvdmlkZWQgaW4geW91ciBpbml0KCkgd2lsbCBzdGlsbCBiZSB0cmlnZ2VyZWQgYXMgbm9ybWFsLFxuICogICBidXQgd2l0aCB0aGVzZSBub3RhYmxlIGV4Y2VwdGlvbnM6XG4gKlxuICogICAgICAtIFRoZXJlIGlzIG5vIHBheWxvYWQgZGF0YSBhdmFpbGFibGUgd2l0aCBtZXNzYWdlc1xuICogICAgICAtIEFuIGFsZXJ0KCkgaXMgY2FsbGVkIHdoZW4gYSBub3RpZmljYXRpb24gaXMgcmVjZWl2ZWQgdW5sZXNzcyB5b3UgcmV0dXJuIGZhbHNlXG4gKiAgICAgICAgaW4geW91ciAnb25Ob3RpZmljYXRpb24nIGNhbGxiYWNrLlxuICpcbiAqL1xudmFyIFB1c2hEZXZTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoRGV2U2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5jbGllbnQ7XG4gICAgICAgIHRoaXMuX3Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2F0Y2ggPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIGRldmVsb3BtZW50IHRva2VuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRldmVsb3BtZW50IGRldmljZSB0b2tlblxuICAgICAqL1xuICAgIFB1c2hEZXZTZXJ2aWNlLnByb3RvdHlwZS5nZXREZXZUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdXRpbF8xLmdlbmVyYXRlVVVJRCgpO1xuICAgICAgICB0aGlzLl90b2tlbiA9ICdERVYtJyArIHRva2VuO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZXZlbG9wbWVudCB0b2tlbiB3aXRoIHRoZSBJb25pYyBQdXNoIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW9uaWNQdXNoU2VydmljZX0gaW9uaWNQdXNoIEluc3RhbnRpYXRlZCBQdXNoIFNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBSZWdpc3RyYXRpb24gQ2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFB1c2hEZXZTZXJ2aWNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGlvbmljUHVzaCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcHVzaCA9IGlvbmljUHVzaDtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy5fdG9rZW47XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXREZXZUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50LnBvc3QoJy9wdXNoL2RldmVsb3BtZW50JylcbiAgICAgICAgICAgIC5zZW5kKHsgJ3Rva2VuJzogdG9rZW4gfSlcbiAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmVycm9yKCdJb25pYyBQdXNoIChkZXYpOiBlcnJvciBjb25uZWN0aW5nIGRldmVsb3BtZW50IHB1c2ggc2VydmljZTogJyArIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHsgJ3JlZ2lzdHJhdGlvbklkJzogdG9rZW4gfTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaCAoZGV2KTogcmVnaXN0ZXJlZCB3aXRoIGRldmVsb3BtZW50IHB1c2ggc2VydmljZTogJyArIHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5lbWl0dGVyLmVtaXQoJ3B1c2g6dG9rZW4nLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBwdXNoX3Rva2VuXzEuUHVzaFRva2VuKF90aGlzLl90b2tlbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy53YXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgcHVzaCBzZXJ2aWNlIGZvciBub3RpZmljYXRpb25zIHRoYXQgdGFyZ2V0IHRoZSBjdXJyZW50IGRldmVsb3BtZW50IHRva2VuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBQdXNoRGV2U2VydmljZS5wcm90b3R5cGUuY2hlY2tGb3JOb3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQuZ2V0KCcvcHVzaC9kZXZlbG9wbWVudCcpXG4gICAgICAgICAgICAucXVlcnkoeyAndG9rZW4nOiB0aGlzLl90b2tlbiB9KVxuICAgICAgICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIFB1c2ggKGRldik6IHVuYWJsZSB0byBjaGVjayBmb3IgZGV2ZWxvcG1lbnQgcHVzaGVzOiAnICsgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXMuYm9keS5kYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZSc6IHJlcy5ib2R5LmRhdGEubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdERVZFTE9QTUVOVCBQVVNIJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIud2FybignSW9uaWMgUHVzaCAoZGV2KTogRGV2ZWxvcG1lbnQgUHVzaCByZWNlaXZlZC4gRGV2ZWxvcG1lbnQgcHVzaGVzIHdpbGwgbm90IGNvbnRhaW4gcGF5bG9hZCBkYXRhLicpO1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5lbWl0dGVyLmVtaXQoJ3B1c2g6bm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEtpY2tzIG9mZiB0aGUgXCJwb2xsaW5nXCIgb2YgdGhlIElvbmljIFB1c2ggc2VydmljZSBmb3IgbmV3IHB1c2ggbm90aWZpY2F0aW9uc1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgUHVzaERldlNlcnZpY2UucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgbmV3IGRldiBwdXNoZXMgZXZlcnkgNSBzZWNvbmRzXG4gICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBQdXNoIChkZXYpOiB3YXRjaGluZyBmb3IgbmV3IG5vdGlmaWNhdGlvbnMnKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3dhdGNoKSB7XG4gICAgICAgICAgICB0aGlzLl93YXRjaCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgc2VsZi5jaGVja0Zvck5vdGlmaWNhdGlvbnMoKTsgfSwgNTAwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1dHMgdGhlIFwicG9sbGluZ1wiIGZvciBuZXcgbm90aWZpY2F0aW9ucyBvbiBob2xkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgUHVzaERldlNlcnZpY2UucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YXRjaCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl93YXRjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQdXNoRGV2U2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlB1c2hEZXZTZXJ2aWNlID0gUHVzaERldlNlcnZpY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBQdXNoTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVzaE1lc3NhZ2UocmF3KSB7XG4gICAgICAgIHRoaXMuYXBwID0ge307XG4gICAgICAgIHRoaXMuX3JhdyA9IHJhdyB8fCB7fTtcbiAgICAgICAgaWYgKCF0aGlzLl9yYXcuYWRkaXRpb25hbERhdGEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGl0IGlmIHdlIGFyZSBzZXJ2aW5nIHVwIGEgZGV2ZWxvcG1lbnQgcHVzaFxuICAgICAgICAgICAgdGhpcy5fcmF3LmFkZGl0aW9uYWxEYXRhID0ge1xuICAgICAgICAgICAgICAgICdjb2xkc3RhcnQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnZm9yZWdyb3VuZCc6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF5bG9hZCA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudGl0bGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgIH1cbiAgICBQdXNoTWVzc2FnZS5mcm9tUGx1Z2luSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IFB1c2hNZXNzYWdlKGpzb24pO1xuICAgICAgICBtZXNzYWdlLnByb2Nlc3NSYXcoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHVzaE1lc3NhZ2UucHJvdG90eXBlLCBcInBheWxvYWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXlsb2FkIHx8IHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQdXNoTWVzc2FnZS5wcm90b3R5cGUucHJvY2Vzc1JhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5fcmF3Lm1lc3NhZ2UgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuX3Jhdy50aXRsZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmNvdW50ID0gdGhpcy5fcmF3LmNvdW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuc291bmQgPSB0aGlzLl9yYXcuc291bmQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5pbWFnZSA9IHRoaXMuX3Jhdy5pbWFnZSB8fCBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX3Jhdy5hZGRpdGlvbmFsRGF0YS5mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5hc2xlZXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yYXcuYWRkaXRpb25hbERhdGEuY29sZHN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yYXcuYWRkaXRpb25hbERhdGEucGF5bG9hZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF5bG9hZCA9IHRoaXMuX3Jhdy5hZGRpdGlvbmFsRGF0YS5wYXlsb2FkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXNoTWVzc2FnZS5wcm90b3R5cGUuZ2V0UmF3VmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhdztcbiAgICB9O1xuICAgIFB1c2hNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICc8UHVzaE1lc3NhZ2UgW1xcJycgKyB0aGlzLnRpdGxlICsgJ1xcJ10+JztcbiAgICB9O1xuICAgIHJldHVybiBQdXNoTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLlB1c2hNZXNzYWdlID0gUHVzaE1lc3NhZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBQdXNoVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hUb2tlbih0b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9XG4gICAgUHVzaFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiPFB1c2hUb2tlbiBbXCIgKyB0aGlzLnRva2VuICsgXCJdPlwiO1xuICAgIH07XG4gICAgcmV0dXJuIFB1c2hUb2tlbjtcbn0oKSk7XG5leHBvcnRzLlB1c2hUb2tlbiA9IFB1c2hUb2tlbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFwcF8xID0gcmVxdWlyZSgnLi4vY29yZS9hcHAnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCcuLi9jb3JlL2NvcmUnKTtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuLi9jb3JlL3Byb21pc2UnKTtcbnZhciB1c2VyXzEgPSByZXF1aXJlKCcuLi9jb3JlL3VzZXInKTtcbnZhciBwdXNoX3Rva2VuXzEgPSByZXF1aXJlKCcuL3B1c2gtdG9rZW4nKTtcbnZhciBwdXNoX21lc3NhZ2VfMSA9IHJlcXVpcmUoJy4vcHVzaC1tZXNzYWdlJyk7XG52YXIgcHVzaF9kZXZfMSA9IHJlcXVpcmUoJy4vcHVzaC1kZXYnKTtcbnZhciBQdXNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdGhpcy5fdG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNsaWVudDtcbiAgICAgICAgdmFyIGFwcCA9IG5ldyBhcHBfMS5BcHAoY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnYXBwX2lkJyksIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwaV9rZXknKSk7XG4gICAgICAgIGFwcC5kZXZQdXNoID0gY29yZV8xLklvbmljUGxhdGZvcm0uY29uZmlnLmdldCgnZGV2X3B1c2gnKTtcbiAgICAgICAgYXBwLmdjbUtleSA9IGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2djbV9rZXknKTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSByZXF1aXJlZCB2YWx1ZXMgdG8gdXNlIHRoaXMgc2VydmljZVxuICAgICAgICBpZiAoIWFwcC5pZCB8fCAhYXBwLmFwaUtleSkge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmVycm9yKCdJb25pYyBQdXNoOiBubyBhcHBfaWQgb3IgYXBpX2tleSBmb3VuZC4gKGh0dHA6Ly9kb2NzLmlvbmljLmlvL2RvY3MvaW8taW5zdGFsbCknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JlXzEuSW9uaWNQbGF0Zm9ybS5kZXZpY2UuaXNBbmRyb2lkKCkgJiYgIWFwcC5kZXZQdXNoICYmICFhcHAuZ2NtS2V5KSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIFB1c2g6IEdDTSBwcm9qZWN0IG51bWJlciBub3QgZm91bmQgKGh0dHA6Ly9kb2NzLmlvbmljLmlvL2RvY3MvcHVzaC1hbmRyb2lkLXNldHVwKScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlYnVnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdG9rZW5SZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ibG9ja1JlZ2lzdHJhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ibG9ja1NhdmVUb2tlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BsdWdpbiA9IG51bGw7XG4gICAgICAgIGlmICghY29uZmlnLmRlZmVySW5pdCkge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ub25SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdChjb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFB1c2gucHJvdG90eXBlLCBcInRva2VuXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGNvcmVfMS5Jb25pY1BsYXRmb3JtLnN0b3JhZ2U7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgcHVzaF90b2tlbl8xLlB1c2hUb2tlbikge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc3RvcmVPYmplY3QoJ2lvbmljX2lvX3B1c2hfdG9rZW4nLCB7ICd0b2tlbic6IHZhbC50b2tlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQdXNoLnByb3RvdHlwZS5nZXRTdG9yYWdlVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gY29yZV8xLklvbmljUGxhdGZvcm0uc3RvcmFnZTtcbiAgICAgICAgdmFyIHRva2VuID0gc3RvcmFnZS5yZXRyaWV2ZU9iamVjdCgnaW9uaWNfaW9fcHVzaF90b2tlbicpO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHVzaF90b2tlbl8xLlB1c2hUb2tlbih0b2tlbi50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQdXNoLnByb3RvdHlwZS5jbGVhclN0b3JhZ2VUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5zdG9yYWdlO1xuICAgICAgICBzdG9yYWdlLmRlbGV0ZU9iamVjdCgnaW9uaWNfaW9fcHVzaF90b2tlbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdCBtZXRob2QgdG8gc2V0dXAgcHVzaCBiZWhhdmlvci9vcHRpb25zXG4gICAgICpcbiAgICAgKiBUaGUgY29uZmlnIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAgIC0gZGVidWcge0Jvb2xlYW59IEVuYWJsZXMgc29tZSBleHRyYSBsb2dnaW5nIGFzIHdlbGwgYXMgc29tZSBkZWZhdWx0IGNhbGxiYWNrIGhhbmRsZXJzXG4gICAgICogICAtIG9uTm90aWZpY2F0aW9uIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBwYXNzZWQgdGhlIG5vdGlmaWNhdGlvbiBvYmplY3RcbiAgICAgKiAgIC0gb25SZWdpc3RlciB7RnVuY3Rpb259IENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIHRoZSByZWdpc3RyYXRpb24gb2JqZWN0XG4gICAgICogICAtIG9uRXJyb3Ige0Z1bmN0aW9ufSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHBhc3NlZCB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICogICAtIHBsdWdpbkNvbmZpZyB7T2JqZWN0fSBQbHVnaW4gY29uZmlndXJhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3Bob25lZ2FwL3Bob25lZ2FwLXBsdWdpbi1wdXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogQHJldHVybiB7UHVzaH0gcmV0dXJucyB0aGUgY2FsbGVkIFB1c2ggaW5zdGFudGlhdGlvblxuICAgICAqL1xuICAgIFB1c2gucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB0aGlzLl9nZXRQdXNoUGx1Z2luKCk7XG4gICAgICAgIGlmICghY29uZmlnLnBsdWdpbkNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLnBsdWdpbkNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JlXzEuSW9uaWNQbGF0Zm9ybS5kZXZpY2UuaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgIC8vIGluamVjdCBnY20ga2V5IGZvciBQdXNoUGx1Z2luXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5wbHVnaW5Db25maWcuYW5kcm9pZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5Db25maWcuYW5kcm9pZCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcucGx1Z2luQ29uZmlnLmFuZHJvaWQuc2VuZGVySWQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcucGx1Z2luQ29uZmlnLmFuZHJvaWQuc2VuZGVySUQgPSB0aGlzLmFwcC5nY21LZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgQ2FsbGJhY2tzXG4gICAgICAgIGlmIChjb25maWcub25SZWdpc3Rlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWdpc3RlckNhbGxiYWNrKGNvbmZpZy5vblJlZ2lzdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9uTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldE5vdGlmaWNhdGlvbkNhbGxiYWNrKGNvbmZpZy5vbk5vdGlmaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5vbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVycm9yQ2FsbGJhY2soY29uZmlnLm9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmVtaXR0ZXIuZW1pdCgncHVzaDpyZWFkeScsIHsgJ2NvbmZpZyc6IHRoaXMuX2NvbmZpZyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQdXNoLnByb3RvdHlwZS5zYXZlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAodG9rZW4udG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4udG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuRGF0YSA9IHtcbiAgICAgICAgICAgICd0b2tlbic6IHRva2VuLFxuICAgICAgICAgICAgJ2FwcF9pZCc6IGNvcmVfMS5Jb25pY1BsYXRmb3JtLmNvbmZpZy5nZXQoJ2FwcF9pZCcpXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0cy5pZ25vcmVfdXNlcikge1xuICAgICAgICAgICAgdmFyIHVzZXIgPSB1c2VyXzEuVXNlci5jdXJyZW50KCk7XG4gICAgICAgICAgICBpZiAodXNlci5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRva2VuRGF0YS51c2VyX2lkID0gdXNlci5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NrU2F2ZVRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5wb3N0KCcvcHVzaC90b2tlbnMnKVxuICAgICAgICAgICAgICAgIC5zZW5kKHRva2VuRGF0YSlcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2NrU2F2ZVRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgUHVzaDonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9ibG9ja1NhdmVUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaDogc2F2ZWQgcHVzaCB0b2tlbjogJyArIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuRGF0YS51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaDogYWRkZWQgcHVzaCB0b2tlbiB0byB1c2VyOiAnICsgdG9rZW5EYXRhLnVzZXJfaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaDogYSB0b2tlbiBzYXZlIG9wZXJhdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzLicpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZGV2aWNlIHdpdGggR0NNL0FQTlMgdG8gZ2V0IGEgZGV2aWNlIHRva2VuXG4gICAgICogRmlyZXMgb2ZmIHRoZSAnb25SZWdpc3RlcicgY2FsbGJhY2sgaWYgb25lIGhhcyBiZWVuIHByb3ZpZGVkIGluIHRoZSBpbml0KCkgY29uZmlnXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFB1c2gucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBQdXNoOiByZWdpc3RlcicpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9ibG9ja1JlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IGFub3RoZXIgcmVnaXN0cmF0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmxvY2tSZWdpc3RyYXRpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuYXBwLmRldlB1c2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgSW9uaWNEZXZQdXNoID0gbmV3IHB1c2hfZGV2XzEuUHVzaERldlNlcnZpY2UoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWJ1Z0NhbGxiYWNrUmVnaXN0cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tSZWdpc3RyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBJb25pY0RldlB1c2guaW5pdChzZWxmLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgc2VsZi5fYmxvY2tSZWdpc3RyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLl90b2tlblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX3BsdWdpbiA9IHNlbGYuX2dldFB1c2hQbHVnaW4oKS5pbml0KHNlbGYuX2NvbmZpZy5wbHVnaW5Db25maWcpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3BsdWdpbi5vbigncmVnaXN0cmF0aW9uJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYmxvY2tSZWdpc3RyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50b2tlbiA9IG5ldyBwdXNoX3Rva2VuXzEuUHVzaFRva2VuKGRhdGEucmVnaXN0cmF0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl90b2tlblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmLl90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWJ1Z0NhbGxiYWNrUmVnaXN0cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tSZWdpc3RyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX3JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgdGhlIGN1cnJlbnQgR0NNL0FQTlMgdG9rZW5cbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB2YXIgcGxhdGZvcm0gPSBudWxsO1xuICAgICAgICBpZiAoY29yZV8xLklvbmljUGxhdGZvcm0uZGV2aWNlLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgICBwbGF0Zm9ybSA9ICdhbmRyb2lkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JlXzEuSW9uaWNQbGF0Zm9ybS5kZXZpY2UuaXNJT1MoKSkge1xuICAgICAgICAgICAgcGxhdGZvcm0gPSAnaW9zJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYXRmb3JtKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ0NvdWxkIG5vdCBkZXRlY3QgdGhlIHBsYXRmb3JtLCBhcmUgeW91IG9uIGEgZGV2aWNlPycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2tVbnJlZ2lzdGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGx1Z2luLnVucmVnaXN0ZXIoZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGllbnQucG9zdCgnL3B1c2gvdG9rZW5zL2ludmFsaWRhdGUnKVxuICAgICAgICAgICAgICAgIC5zZW5kKHtcbiAgICAgICAgICAgICAgICAncGxhdGZvcm0nOiBwbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICAndG9rZW4nOiB0aGlzLmdldFN0b3JhZ2VUb2tlbigpLnRva2VuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmxvY2tVbnJlZ2lzdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgUHVzaDonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9ibG9ja1VucmVnaXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IHVucmVnaXN0ZXJlZCBwdXNoIHRva2VuOiAnICsgX3RoaXMuZ2V0U3RvcmFnZVRva2VuKCkudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhclN0b3JhZ2VUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaDogYW4gdW5yZWdpc3RlciBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy4nKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gZ3JhYiB0aGUgcGF5bG9hZCBvYmplY3QgZnJvbSBhIG5vdGlmaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtQdXNoTm90aWZpY2F0aW9ufSBub3RpZmljYXRpb24gUHVzaCBOb3RpZmljYXRpb24gb2JqZWN0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBQYXlsb2FkIG9iamVjdCBvciBhbiBlbXB0eSBvYmplY3RcbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5nZXRQYXlsb2FkID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uLnBheWxvYWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJlZ2lzdHJhdGlvbiBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgUmVnaXN0cmF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBzZXQgY29ycmVjdGx5LCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5zZXRSZWdpc3RlckNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBQdXNoOiBzZXRSZWdpc3RlckNhbGxiYWNrKCkgcmVxdWlyZXMgYSB2YWxpZCBjYWxsYmFjayBmdW5jdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBOb3RpZmljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHNldCBjb3JyZWN0bHksIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIFB1c2gucHJvdG90eXBlLnNldE5vdGlmaWNhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5pbmZvKCdJb25pYyBQdXNoOiBzZXROb3RpZmljYXRpb25DYWxsYmFjaygpIHJlcXVpcmVzIGEgdmFsaWQgY2FsbGJhY2sgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBlcnJvciBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRXJyb3IgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHNldCBjb3JyZWN0bHksIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIFB1c2gucHJvdG90eXBlLnNldEVycm9yQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IHNldEVycm9yQ2FsbGJhY2soKSByZXF1aXJlcyBhIHZhbGlkIGNhbGxiYWNrIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUHVzaC5wcm90b3R5cGUuX2RlYnVnUmVnaXN0cmF0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZGF0YSkge1xuICAgICAgICAgICAgc2VsZi50b2tlbiA9IG5ldyBwdXNoX3Rva2VuXzEuUHVzaFRva2VuKGRhdGEucmVnaXN0cmF0aW9uSWQpO1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0ubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IChkZWJ1ZykgZGV2aWNlIHRva2VuIHJlZ2lzdGVyZWQ6ICcgKyBzZWxmLl90b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG4gICAgUHVzaC5wcm90b3R5cGUuX2RlYnVnTm90aWZpY2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2sobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICBzZWxmLl9wcm9jZXNzTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHB1c2hfbWVzc2FnZV8xLlB1c2hNZXNzYWdlLmZyb21QbHVnaW5KU09OKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaDogKGRlYnVnKSBub3RpZmljYXRpb24gcmVjZWl2ZWQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5ub3RpZmljYXRpb25DYWxsYmFjayAmJiBzZWxmLmFwcC5kZXZQdXNoKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQobWVzc2FnZS50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBQdXNoLnByb3RvdHlwZS5fZGVidWdFcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnIpIHtcbiAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmxvZ2dlci5lcnJvcignSW9uaWMgUHVzaDogKGRlYnVnKSB1bmV4cGVjdGVkIGVycm9yIG9jY3VyZWQuJyk7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIFB1c2g6JywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBQdXNoLnByb3RvdHlwZS5fcmVnaXN0ZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhkYXRhKSB7XG4gICAgICAgICAgICBzZWxmLnRva2VuID0gbmV3IHB1c2hfdG9rZW5fMS5QdXNoVG9rZW4oZGF0YS5yZWdpc3RyYXRpb25JZCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZWdpc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0ZXJDYWxsYmFjayhzZWxmLl90b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG4gICAgUHVzaC5wcm90b3R5cGUuX25vdGlmaWNhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKG5vdGlmaWNhdGlvbikge1xuICAgICAgICAgICAgc2VsZi5fcHJvY2Vzc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBwdXNoX21lc3NhZ2VfMS5QdXNoTWVzc2FnZS5mcm9tUGx1Z2luSlNPTihub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgaWYgKHNlbGYubm90aWZpY2F0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ub3RpZmljYXRpb25DYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBQdXNoLnByb3RvdHlwZS5fZXJyb3JDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnIpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5lcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBkZWZhdWx0IGRlYnVnIGNhbGxiYWNrcyB3aXRoIHRoZSBQdXNoUGx1Z2luIHdoZW4gZGVidWcgaXMgZW5hYmxlZFxuICAgICAqIEludGVybmFsIE1ldGhvZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5fZGVidWdDYWxsYmFja1JlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFwcC5kZXZQdXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGx1Z2luLm9uKCdyZWdpc3RyYXRpb24nLCB0aGlzLl9kZWJ1Z1JlZ2lzdHJhdGlvbkNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsdWdpbi5vbignbm90aWZpY2F0aW9uJywgdGhpcy5fZGVidWdOb3RpZmljYXRpb25DYWxsYmFjaygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbHVnaW4ub24oJ2Vycm9yJywgdGhpcy5fZGVidWdFcnJvckNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmVtaXR0ZXIub24oJ3B1c2g6dG9rZW4nLCB0aGlzLl9kZWJ1Z1JlZ2lzdHJhdGlvbkNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5lbWl0dGVyLm9uKCdwdXNoOm5vdGlmaWNhdGlvbicsIHRoaXMuX2RlYnVnTm90aWZpY2F0aW9uQ2FsbGJhY2soKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmVtaXR0ZXIub24oJ3B1c2g6ZXJyb3InLCB0aGlzLl9kZWJ1Z0Vycm9yQ2FsbGJhY2soKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIHVzZXIgc3VwcGxpZWQgY2FsbGJhY2tzIHdpdGggdGhlIFB1c2hQbHVnaW5cbiAgICAgKiBJbnRlcm5hbCBNZXRob2RcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFB1c2gucHJvdG90eXBlLl9jYWxsYmFja1JlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwcC5kZXZQdXNoKSB7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW4ub24oJ3JlZ2lzdHJhdGlvbicsIHRoaXMuX3JlZ2lzdGVyQ2FsbGJhY2soKSk7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW4ub24oJ25vdGlmaWNhdGlvbicsIHRoaXMuX25vdGlmaWNhdGlvbkNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5fcGx1Z2luLm9uKCdlcnJvcicsIHRoaXMuX2Vycm9yQ2FsbGJhY2soKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5lbWl0dGVyLm9uKCdwdXNoOnRva2VuJywgdGhpcy5fcmVnaXN0ZXJDYWxsYmFjaygpKTtcbiAgICAgICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5lbWl0dGVyLm9uKCdwdXNoOm5vdGlmaWNhdGlvbicsIHRoaXMuX25vdGlmaWNhdGlvbkNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgICAgIGNvcmVfMS5Jb25pY1BsYXRmb3JtLmVtaXR0ZXIub24oJ3B1c2g6ZXJyb3InLCB0aGlzLl9lcnJvckNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBtaXNjIGZlYXR1cmVzIGJhc2VkIG9uIHRoZSBjb250ZW50cyBvZiBhIHB1c2ggbm90aWZpY2F0aW9uXG4gICAgICogSW50ZXJuYWwgTWV0aG9kXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkganVzdCBkb2VzIHRoZSBwYXlsb2FkICRzdGF0ZSByZWRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7UHVzaE5vdGlmaWNhdGlvbn0gbm90aWZpY2F0aW9uIFB1c2ggTm90aWZpY2F0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgUHVzaC5wcm90b3R5cGUuX3Byb2Nlc3NOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcbiAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0uZW1pdHRlci5lbWl0KCdwdXNoOnByb2Nlc3NOb3RpZmljYXRpb24nLCBub3RpZmljYXRpb24pO1xuICAgIH07XG4gICAgLyogRGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgZ2V0UHVzaFBsdWdpbmAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5fZ2V0UHVzaFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFB1c2hQbHVnaW4gPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUHVzaFBsdWdpbiA9IHdpbmRvdy5QdXNoTm90aWZpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaDogc29tZXRoaW5nIHdlbnQgd3JvbmcgbG9va2luZyBmb3IgdGhlIFB1c2hOb3RpZmljYXRpb24gcGx1Z2luJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFwcC5kZXZQdXNoICYmICFQdXNoUGx1Z2luICYmIChjb3JlXzEuSW9uaWNQbGF0Zm9ybS5kZXZpY2UuaXNJT1MoKSB8fCBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5kZXZpY2UuaXNBbmRyb2lkKCkpKSB7XG4gICAgICAgICAgICBjb3JlXzEuSW9uaWNQbGF0Zm9ybS5sb2dnZXIuZXJyb3IoJ0lvbmljIFB1c2g6IFB1c2hOb3RpZmljYXRpb24gcGx1Z2luIGlzIHJlcXVpcmVkLiBIYXZlIHlvdSBydW4gYGlvbmljIHBsdWdpbiBhZGQgcGhvbmVnYXAtcGx1Z2luLXB1c2hgID8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHVzaFBsdWdpbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBwaG9uZWdhcC1wdXNoLXBsdWdpbiBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1B1c2hOb3RpZmljYXRpb259IFB1c2hOb3RpZmljYXRpb24gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5nZXRQdXNoUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGx1Z2luO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlyZSBhIGNhbGxiYWNrIHdoZW4gUHVzaCBpcyByZWFkeS4gVGhpcyB3aWxsIGZpcmUgaW1tZWRpYXRlbHkgaWZcbiAgICAgKiB0aGUgc2VydmljZSBoYXMgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb2ZmXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2lzUmVhZHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29yZV8xLklvbmljUGxhdGZvcm0uZW1pdHRlci5vbigncHVzaDpyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUHVzaDtcbn0oKSk7XG5leHBvcnRzLlB1c2ggPSBQdXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuX19leHBvcnQocmVxdWlyZSgnLi91dGlsJykpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBkZWVwRXh0ZW5kKCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvdXRbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIG91dCA9IG91dFswXSB8fCB7fTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2tleV0gPSBkZWVwRXh0ZW5kKG91dFtrZXldLCBvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5kZWVwRXh0ZW5kID0gZGVlcEV4dGVuZDtcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnRzLmdlbmVyYXRlVVVJRCA9IGdlbmVyYXRlVVVJRDtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdyZWR1Y2UnKTtcbnZhciByZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHsgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIHJvb3QgPSB0aGlzO1xufVxuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogVE9ETzogZnV0dXJlIHByb29mLCBtb3ZlIHRvIGNvbXBvZW50IGxhbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNIb3N0KG9iaikge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIHN3aXRjaCAoc3RyKSB7XG4gICAgY2FzZSAnW29iamVjdCBGaWxlXSc6XG4gICAgY2FzZSAnW29iamVjdCBCbG9iXSc6XG4gICAgY2FzZSAnW29iamVjdCBGb3JtRGF0YV0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpLmJpbmQobnVsbCwgUmVxdWVzdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHRyaW0gPSAnJy50cmltXG4gID8gZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH1cbiAgOiBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpOyB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG51bGwgIT0gb2JqW2tleV0pIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgIH0pO1xuICB9XG4gIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4gLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFydHM7XG4gIHZhciBwYWlyO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwYXJ0cyA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ2FwcGxpY2F0aW9uL3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXJpYWxpemF0aW9uIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcbiAqICAgICAgIHJldHVybiAnZ2VuZXJhdGVkIHhtbCBoZXJlJztcbiAqICAgICB9O1xuICpcbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnN0cmluZ2lmeVxuIH07XG5cbiAvKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgbGluZXMucG9wKCk7IC8vIHRyYWlsaW5nIENSTEZcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICByZXR1cm4gL1tcXC8rXWpzb25cXGIvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0eXBlKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcmFtcyhzdHIpe1xuICByZXR1cm4gcmVkdWNlKHN0ci5zcGxpdCgvICo7ICovKSwgZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKVxuICAgICAgLCBrZXkgPSBwYXJ0cy5zaGlmdCgpXG4gICAgICAsIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdGhpcy5zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcbiAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgID8gdGhpcy5wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgOiBudWxsO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICB2YXIgb2JqID0gcGFyYW1zKGN0KTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgdGhpc1trZXldID0gb2JqW2tleV07XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnBhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cil7XG4gIHZhciBwYXJzZSA9IHJlcXVlc3QucGFyc2VbdGhpcy50eXBlXTtcbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnNldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgID8gdGhpcy50b0Vycm9yKClcbiAgICA6IGZhbHNlO1xuXG4gIC8vIHN1Z2FyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5yYXdSZXNwb25zZSA9IHNlbGYueGhyICYmIHNlbGYueGhyLnJlc3BvbnNlVGV4dCA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGVyci5zdGF0dXNDb2RlID0gc2VsZi54aHIgJiYgc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDApIHtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuXG4gICAgc2VsZi5jYWxsYmFjayhuZXdfZXJyLCByZXMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGByZXF1ZXN0QmFzZWAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBrZXkgaW4gcmVxdWVzdEJhc2UpIHtcbiAgUmVxdWVzdC5wcm90b3R5cGVba2V5XSA9IHJlcXVlc3RCYXNlW2tleV07XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmFib3J0ZWQpIHJldHVybjtcbiAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIuYWJvcnQoKTtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHJlc3BvbnNlVHlwZSB0byBgdmFsYC4gUHJlc2VudGx5IHZhbGlkIHJlc3BvbnNlVHlwZXMgYXJlICdibG9iJyBhbmQgXG4gKiAnYXJyYXlidWZmZXInLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycgb3IgJ2Jhc2ljJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdiYXNpYydcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBzdHIpO1xuICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYGZpbGVuYW1lYC5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2gobmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIGZpbGVuYW1lKXtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIGZpbGVuYW1lIHx8IGZpbGUubmFtZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAgKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAgKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIC8vIG1lcmdlXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gdGhpcy5fZGF0YSArICcmJyArIGRhdGFcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIW9iaiB8fCBpc0hvc3QoZGF0YSkpIHJldHVybiB0aGlzO1xuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuUmVzcG9uc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgaWYgKHJvb3QuY29uc29sZSkge1xuICAgIGNvbnNvbGUud2FybihcIkNsaWVudC1zaWRlIHBhcnNlKCkgbWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gc2VyaWFsaXplKCkuIFRoaXMgbWV0aG9kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggc3VwZXJhZ2VudCB2Mi4wXCIpO1xuICB9XG4gIHRoaXMuc2VyaWFsaXplKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgdmFyIGZuID0gdGhpcy5fY2FsbGJhY2s7XG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50aW1lb3V0RXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSB0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCk7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKDAgPT0gc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCkgcmV0dXJuIHNlbGYudGltZW91dEVycm9yKCk7XG4gICAgICBpZiAoc2VsZi5hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZSl7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gJ2Rvd25sb2FkJztcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3M7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAoeGhyLnVwbG9hZCAmJiB0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3M7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gIH1cblxuICAvLyB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi50aW1lZG91dCA9IHRydWU7XG4gICAgICBzZWxmLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAvLyBxdWVyeXN0cmluZ1xuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0KHF1ZXJ5KTtcbiAgICB0aGlzLnVybCArPSB+dGhpcy51cmwuaW5kZXhPZignPycpXG4gICAgICA/ICcmJyArIHF1ZXJ5XG4gICAgICA6ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgfSBlbHNlIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICgnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIWlzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX3BhcnNlciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0YC5cbiAqL1xuXG5yZXF1ZXN0LlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPSBvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZvcmNlIGdpdmVuIHBhcnNlclxuICpcbiAqIFNldHMgdGhlIGJvZHkgcGFyc2VyIG5vIG1hdHRlciB0eXBlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXQgdG8gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG1zKXtcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmF1eCBwcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuZXhwb3J0cy50aGVuID0gZnVuY3Rpb24gdGhlbihmdWxmaWxsLCByZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgZXJyID8gcmVqZWN0KGVycikgOiBmdWxmaWxsKHJlcyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbmV4cG9ydHMuZ2V0SGVhZGVyID0gZXhwb3J0cy5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuZXhwb3J0cy51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICogcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIi8vIFRoZSBub2RlIGFuZCBicm93c2VyIG1vZHVsZXMgZXhwb3NlIHZlcnNpb25zIG9mIHRoaXMgd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGJvdW5kIGFzIGZpcnN0IGFyZ3VtZW50XG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChSZXF1ZXN0Q29uc3RydWN0b3IsIG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0Q29uc3RydWN0b3IoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcihtZXRob2QsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIlxuLyoqXG4gKiBSZWR1Y2UgYGFycmAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxcbiAqXG4gKiBUT0RPOiBjb21iYXRpYmxlIGVycm9yIGhhbmRsaW5nP1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCl7ICBcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgY3VyciA9IGFyZ3VtZW50cy5sZW5ndGggPT0gM1xuICAgID8gaW5pdGlhbFxuICAgIDogYXJyW2lkeCsrXTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgY3VyciA9IGZuLmNhbGwobnVsbCwgY3VyciwgYXJyW2lkeF0sICsraWR4LCBhcnIpO1xuICB9XG4gIFxuICByZXR1cm4gY3Vycjtcbn07IiwiLy8gQWRkIEFuZ3VsYXIgaW50ZWdyYXRpb25zIGlmIEFuZ3VsYXIgaXMgYXZhaWxhYmxlXG5pZiAoKHR5cGVvZiBhbmd1bGFyID09PSAnb2JqZWN0JykgJiYgYW5ndWxhci5tb2R1bGUpIHtcblxuICB2YXIgSW9uaWNBbmd1bGFyQW5hbHl0aWNzID0gbnVsbDtcblxuICBhbmd1bGFyLm1vZHVsZSgnaW9uaWMuc2VydmljZS5hbmFseXRpY3MnLCBbJ2lvbmljJ10pXG5cbiAgLnZhbHVlKCdJT05JQ19BTkFMWVRJQ1NfVkVSU0lPTicsIElvbmljLkFuYWx5dGljcy52ZXJzaW9uKVxuXG4gIC5mYWN0b3J5KCckaW9uaWNBbmFseXRpY3MnLCBbZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFJb25pY0FuZ3VsYXJBbmFseXRpY3MpIHtcbiAgICAgIElvbmljQW5ndWxhckFuYWx5dGljcyA9IG5ldyBJb25pYy5BbmFseXRpY3MoXCJERUZFUl9SRUdJU1RFUlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIElvbmljQW5ndWxhckFuYWx5dGljcztcbiAgfV0pXG5cbiAgLmZhY3RvcnkoJ2RvbVNlcmlhbGl6ZXInLCBbZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBJb25pYy5BbmFseXRpY1NlcmlhbGl6ZXJzLkRPTVNlcmlhbGl6ZXIoKTtcbiAgfV0pXG5cbiAgLnJ1bihbJyRpb25pY0FuYWx5dGljcycsICckc3RhdGUnLCBmdW5jdGlvbigkaW9uaWNBbmFseXRpY3MsICRzdGF0ZSkge1xuICAgICRpb25pY0FuYWx5dGljcy5zZXRHbG9iYWxQcm9wZXJ0aWVzKGZ1bmN0aW9uKGV2ZW50Q29sbGVjdGlvbiwgZXZlbnREYXRhKSB7XG4gICAgICBpZiAoIWV2ZW50RGF0YS5fdWkpIHtcbiAgICAgICAgZXZlbnREYXRhLl91aSA9IHt9O1xuICAgICAgfVxuICAgICAgZXZlbnREYXRhLl91aS5hY3RpdmVfc3RhdGUgPSAkc3RhdGUuY3VycmVudC5uYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfSk7XG4gIH1dKTtcblxuXG4gIGFuZ3VsYXIubW9kdWxlKCdpb25pYy5zZXJ2aWNlLmFuYWx5dGljcycpXG5cbiAgLnByb3ZpZGVyKCckaW9uaWNBdXRvVHJhY2snLFtmdW5jdGlvbigpIHtcblxuICAgIHZhciB0cmFja2Vyc0Rpc2FibGVkID0ge30sXG4gICAgICBhbGxUcmFja2Vyc0Rpc2FibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmRpc2FibGVUcmFja2luZyA9IGZ1bmN0aW9uKHRyYWNrZXIpIHtcbiAgICAgIGlmICh0cmFja2VyKSB7XG4gICAgICAgIHRyYWNrZXJzRGlzYWJsZWRbdHJhY2tlcl0gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsVHJhY2tlcnNEaXNhYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuJGdldCA9IFtmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwiaXNFbmFibGVkXCI6IGZ1bmN0aW9uKHRyYWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gIWFsbFRyYWNrZXJzRGlzYWJsZWQgJiYgIXRyYWNrZXJzRGlzYWJsZWRbdHJhY2tlcl07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV07XG4gIH1dKVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQXV0byB0cmFja2Vyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLnJ1bihbJyRpb25pY0F1dG9UcmFjaycsICckaW9uaWNBbmFseXRpY3MnLCBmdW5jdGlvbigkaW9uaWNBdXRvVHJhY2ssICRpb25pY0FuYWx5dGljcykge1xuICAgIGlmICghJGlvbmljQXV0b1RyYWNrLmlzRW5hYmxlZCgnTG9hZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICRpb25pY0FuYWx5dGljcy50cmFjaygnTG9hZCcpO1xuICB9XSlcblxuICAucnVuKFtcbiAgICAnJGlvbmljQXV0b1RyYWNrJyxcbiAgICAnJGRvY3VtZW50JyxcbiAgICAnJGlvbmljQW5hbHl0aWNzJyxcbiAgICAnZG9tU2VyaWFsaXplcicsXG4gICAgZnVuY3Rpb24oJGlvbmljQXV0b1RyYWNrLCAkZG9jdW1lbnQsICRpb25pY0FuYWx5dGljcywgZG9tU2VyaWFsaXplcikge1xuICAgICAgaWYgKCEkaW9uaWNBdXRvVHJhY2suaXNFbmFibGVkKCdUYXAnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICRkb2N1bWVudC5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyB3YW50IGNvb3JkaW5hdGVzIGFzIGEgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgdmFyIGJveCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICB3aWR0aCA9IGJveC5yaWdodCAtIGJveC5sZWZ0LFxuICAgICAgICAgIGhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wLFxuICAgICAgICAgIG5vcm1YID0gKGV2ZW50LnBhZ2VYIC0gYm94LmxlZnQpIC8gd2lkdGgsXG4gICAgICAgICAgbm9ybVkgPSAoZXZlbnQucGFnZVkgLSBib3gudG9wKSAvIGhlaWdodDtcblxuICAgICAgICB2YXIgZXZlbnREYXRhID0ge1xuICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjoge1xuICAgICAgICAgICAgXCJ4XCI6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgXCJ5XCI6IGV2ZW50LnBhZ2VZXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRhcmdldFwiOiBkb21TZXJpYWxpemVyLmVsZW1lbnRTZWxlY3RvcihldmVudC50YXJnZXQpLFxuICAgICAgICAgIFwidGFyZ2V0X2lkZW50aWZpZXJcIjogZG9tU2VyaWFsaXplci5lbGVtZW50TmFtZShldmVudC50YXJnZXQpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzRmluaXRlKG5vcm1YKSAmJiBpc0Zpbml0ZShub3JtWSkpIHtcbiAgICAgICAgICBldmVudERhdGEuY29vcmRpbmF0ZXMueF9ub3JtID0gbm9ybVg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICBldmVudERhdGEuY29vcmRpbmF0ZXMueV9ub3JtID0gbm9ybVk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgICRpb25pY0FuYWx5dGljcy50cmFjaygnVGFwJywge1xuICAgICAgICAgIFwiX3VpXCI6IGV2ZW50RGF0YVxuICAgICAgICB9KTtcblxuICAgICAgfSk7XG4gICAgfVxuICBdKVxuXG4gIC5ydW4oW1xuICAgICckaW9uaWNBdXRvVHJhY2snLFxuICAgICckaW9uaWNBbmFseXRpY3MnLFxuICAgICckcm9vdFNjb3BlJyxcbiAgICBmdW5jdGlvbigkaW9uaWNBdXRvVHJhY2ssICRpb25pY0FuYWx5dGljcywgJHJvb3RTY29wZSkge1xuICAgICAgaWYgKCEkaW9uaWNBdXRvVHJhY2suaXNFbmFibGVkKCdTdGF0ZSBDaGFuZ2UnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQsIHRvU3RhdGUsIHRvUGFyYW1zLCBmcm9tU3RhdGUsIGZyb21QYXJhbXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAkaW9uaWNBbmFseXRpY3MudHJhY2soJ1N0YXRlIENoYW5nZScsIHtcbiAgICAgICAgICBcImZyb21cIjogZnJvbVN0YXRlLm5hbWUsXG4gICAgICAgICAgXCJ0b1wiOiB0b1N0YXRlLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIF0pXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gaW9uLXRyYWNrLSRFVkVOVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBAbmdkb2MgZGlyZWN0aXZlXG4gICAqIEBuYW1lIGlvblRyYWNrQ2xpY2tcbiAgICogQG1vZHVsZSBpb25pYy5zZXJ2aWNlLmFuYWx5dGljc1xuICAgKiBAcmVzdHJpY3QgQVxuICAgKiBAcGFyZW50IGlvbmljLmRpcmVjdGl2ZTppb25UcmFja0NsaWNrXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBBIGNvbnZlbmllbnQgZGlyZWN0aXZlIHRvIGF1dG9tYXRpY2FsbHkgdHJhY2sgYSBjbGljay90YXAgb24gYSBidXR0b25cbiAgICogb3Igb3RoZXIgdGFwcGFibGUgZWxlbWVudC5cbiAgICpcbiAgICogQHVzYWdlXG4gICAqIGBgYGh0bWxcbiAgICogPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBidXR0b24tY2xlYXJcIiBpb24tdHJhY2stY2xpY2sgaW9uLXRyYWNrLWV2ZW50PVwiY3RhLXRhcFwiPlRyeSBub3chPC9idXR0b24+XG4gICAqIGBgYFxuICAgKi9cblxuICAuZGlyZWN0aXZlKCdpb25UcmFja0NsaWNrJywgaW9uVHJhY2tEaXJlY3RpdmUoJ2NsaWNrJykpXG4gIC5kaXJlY3RpdmUoJ2lvblRyYWNrVGFwJywgaW9uVHJhY2tEaXJlY3RpdmUoJ3RhcCcpKVxuICAuZGlyZWN0aXZlKCdpb25UcmFja0RvdWJsZXRhcCcsIGlvblRyYWNrRGlyZWN0aXZlKCdkb3VibGV0YXAnKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tIb2xkJywgaW9uVHJhY2tEaXJlY3RpdmUoJ2hvbGQnKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tSZWxlYXNlJywgaW9uVHJhY2tEaXJlY3RpdmUoJ3JlbGVhc2UnKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tEcmFnJywgaW9uVHJhY2tEaXJlY3RpdmUoJ2RyYWcnKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tEcmFnTGVmdCcsIGlvblRyYWNrRGlyZWN0aXZlKCdkcmFnbGVmdCcpKVxuICAuZGlyZWN0aXZlKCdpb25UcmFja0RyYWdSaWdodCcsIGlvblRyYWNrRGlyZWN0aXZlKCdkcmFncmlnaHQnKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tEcmFnVXAnLCBpb25UcmFja0RpcmVjdGl2ZSgnZHJhZ3VwJykpXG4gIC5kaXJlY3RpdmUoJ2lvblRyYWNrRHJhZ0Rvd24nLCBpb25UcmFja0RpcmVjdGl2ZSgnZHJhZ2Rvd24nKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tTd2lwZUxlZnQnLCBpb25UcmFja0RpcmVjdGl2ZSgnc3dpcGVsZWZ0JykpXG4gIC5kaXJlY3RpdmUoJ2lvblRyYWNrU3dpcGVSaWdodCcsIGlvblRyYWNrRGlyZWN0aXZlKCdzd2lwZXJpZ2h0JykpXG4gIC5kaXJlY3RpdmUoJ2lvblRyYWNrU3dpcGVVcCcsIGlvblRyYWNrRGlyZWN0aXZlKCdzd2lwZXVwJykpXG4gIC5kaXJlY3RpdmUoJ2lvblRyYWNrU3dpcGVEb3duJywgaW9uVHJhY2tEaXJlY3RpdmUoJ3N3aXBlZG93bicpKVxuICAuZGlyZWN0aXZlKCdpb25UcmFja1RyYW5zZm9ybScsIGlvblRyYWNrRGlyZWN0aXZlKCdob2xkJykpXG4gIC5kaXJlY3RpdmUoJ2lvblRyYWNrUGluY2gnLCBpb25UcmFja0RpcmVjdGl2ZSgncGluY2gnKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tQaW5jaEluJywgaW9uVHJhY2tEaXJlY3RpdmUoJ3BpbmNoaW4nKSlcbiAgLmRpcmVjdGl2ZSgnaW9uVHJhY2tQaW5jaE91dCcsIGlvblRyYWNrRGlyZWN0aXZlKCdwaW5jaG91dCcpKVxuICAuZGlyZWN0aXZlKCdpb25UcmFja1JvdGF0ZScsIGlvblRyYWNrRGlyZWN0aXZlKCdyb3RhdGUnKSk7XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgZGlyZWN0aXZlIHRvIGNyZWF0ZSBhdXRvIGV2ZW50IGhhbmRsaW5nIGFuYWx5dGljcyBkaXJlY3RpdmVzIGxpa2U6XG4gICAqXG4gICAqIDxidXR0b24gaW9uLXRyYWNrLWNsaWNrPVwiZXZlbnROYW1lXCI+Q2xpY2sgVHJhY2s8L2J1dHRvbj5cbiAgICogPGJ1dHRvbiBpb24tdHJhY2staG9sZD1cImV2ZW50TmFtZVwiPkhvbGQgVHJhY2s8L2J1dHRvbj5cbiAgICogPGJ1dHRvbiBpb24tdHJhY2stdGFwPVwiZXZlbnROYW1lXCI+VGFwIFRyYWNrPC9idXR0b24+XG4gICAqIDxidXR0b24gaW9uLXRyYWNrLWRvdWJsZXRhcD1cImV2ZW50TmFtZVwiPkRvdWJsZSBUYXAgVHJhY2s8L2J1dHRvbj5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRvbUV2ZW50TmFtZSBUaGUgRE9NIGV2ZW50IG5hbWVcbiAgICogQHJldHVybiB7YXJyYXl9IEFuZ3VsYXIgRGlyZWN0aXZlIGRlY2xhcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBpb25UcmFja0RpcmVjdGl2ZShkb21FdmVudE5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHJldHVybiBbJyRpb25pY0FuYWx5dGljcycsICckaW9uaWNHZXN0dXJlJywgZnVuY3Rpb24oJGlvbmljQW5hbHl0aWNzLCAkaW9uaWNHZXN0dXJlKSB7XG5cbiAgICAgIHZhciBnZXN0dXJlRHJpdmVuID0gW1xuICAgICAgICAnZHJhZycsICdkcmFnc3RhcnQnLCAnZHJhZ2VuZCcsICdkcmFnbGVmdCcsICdkcmFncmlnaHQnLCAnZHJhZ3VwJywgJ2RyYWdkb3duJyxcbiAgICAgICAgJ3N3aXBlJywgJ3N3aXBlbGVmdCcsICdzd2lwZXJpZ2h0JywgJ3N3aXBldXAnLCAnc3dpcGVkb3duJyxcbiAgICAgICAgJ3RhcCcsICdkb3VibGV0YXAnLCAnaG9sZCcsXG4gICAgICAgICd0cmFuc2Zvcm0nLCAncGluY2gnLCAncGluY2hpbicsICdwaW5jaG91dCcsICdyb3RhdGUnXG4gICAgICBdO1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB1c2UgdGhlIGdlc3R1cmUgc3Vic3lzdGVtIG9yIHRoZSBET00gc3lzdGVtXG4gICAgICB2YXIgaXNHZXN0dXJlRHJpdmVuID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlc3R1cmVEcml2ZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGdlc3R1cmVEcml2ZW5baV0gPT09IGRvbUV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgaXNHZXN0dXJlRHJpdmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJyZXN0cmljdFwiOiAnQScsXG4gICAgICAgIFwibGlua1wiOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cikge1xuICAgICAgICAgIHZhciBjYXBpdGFsaXplZCA9IGRvbUV2ZW50TmFtZVswXS50b1VwcGVyQ2FzZSgpICsgZG9tRXZlbnROYW1lLnNsaWNlKDEpO1xuICAgICAgICAgIC8vIEdyYWIgZXZlbnQgbmFtZSB3ZSB3aWxsIHNlbmRcbiAgICAgICAgICB2YXIgZXZlbnROYW1lID0gJGF0dHJbJ2lvblRyYWNrJyArIGNhcGl0YWxpemVkXTtcblxuICAgICAgICAgIGlmIChpc0dlc3R1cmVEcml2ZW4pIHtcbiAgICAgICAgICAgIHZhciBnZXN0dXJlID0gJGlvbmljR2VzdHVyZS5vbihkb21FdmVudE5hbWUsIGhhbmRsZXIsICRlbGVtZW50KTtcbiAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRpb25pY0dlc3R1cmUub2ZmKGdlc3R1cmUsIGRvbUV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGVsZW1lbnQub24oZG9tRXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRlbGVtZW50Lm9mZihkb21FdmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSAkc2NvcGUuJGV2YWwoJGF0dHIuaW9uVHJhY2tEYXRhKSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgJGlvbmljQW5hbHl0aWNzLnRyYWNrKGV2ZW50TmFtZSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRpb25pY0FuYWx5dGljcy50cmFja0NsaWNrKGUucGFnZVgsIGUucGFnZVksIGUudGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGV2ZW50RGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV07XG4gIH1cblxufVxuIiwiLy8gQWRkIEFuZ3VsYXIgaW50ZWdyYXRpb25zIGlmIEFuZ3VsYXIgaXMgYXZhaWxhYmxlXG5pZiAoKHR5cGVvZiBhbmd1bGFyID09PSAnb2JqZWN0JykgJiYgYW5ndWxhci5tb2R1bGUpIHtcblxuICB2YXIgSW9uaWNBbmd1bGFyQXV0aCA9IG51bGw7XG5cbiAgYW5ndWxhci5tb2R1bGUoJ2lvbmljLnNlcnZpY2UuYXV0aCcsIFtdKVxuXG4gIC5mYWN0b3J5KCckaW9uaWNBdXRoJywgW2Z1bmN0aW9uKCkge1xuICAgIGlmICghSW9uaWNBbmd1bGFyQXV0aCkge1xuICAgICAgSW9uaWNBbmd1bGFyQXV0aCA9IElvbmljLkF1dGg7XG4gICAgfVxuICAgIHJldHVybiBJb25pY0FuZ3VsYXJBdXRoO1xuICB9XSk7XG59XG4iLCIvLyBBZGQgQW5ndWxhciBpbnRlZ3JhdGlvbnMgaWYgQW5ndWxhciBpcyBhdmFpbGFibGVcbmlmICgodHlwZW9mIGFuZ3VsYXIgPT09ICdvYmplY3QnKSAmJiBhbmd1bGFyLm1vZHVsZSkge1xuICBhbmd1bGFyLm1vZHVsZSgnaW9uaWMuc2VydmljZS5jb3JlJywgW10pXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFByb3ZpZGVzIGEgc2FmZSBpbnRlcmZhY2UgdG8gc3RvcmUgb2JqZWN0cyBpbiBwZXJzaXN0ZW50IG1lbW9yeVxuICAgKi9cbiAgLnByb3ZpZGVyKCdwZXJzaXN0ZW50U3RvcmFnZScsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnJGdldCc6IFtmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBJb25pYy5nZXRTZXJ2aWNlKCdTdG9yYWdlJyk7XG4gICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgIHN0b3JhZ2UgPSBuZXcgSW9uaWMuSU8uU3RvcmFnZSgpO1xuICAgICAgICAgIElvbmljLmFkZFNlcnZpY2UoJ1N0b3JhZ2UnLCBzdG9yYWdlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICAgIH1dXG4gICAgfTtcbiAgfSlcblxuICAuZmFjdG9yeSgnJGlvbmljQ29yZScsIFtcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJb25pYy5Db3JlO1xuICAgIH1cbiAgXSlcblxuICAuZmFjdG9yeSgnJGlvbmljQ29yZVNldHRpbmdzJywgW1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElvbmljLklPLkNvbmZpZztcbiAgICB9XG4gIF0pXG5cbiAgLmZhY3RvcnkoJyRpb25pY1VzZXInLCBbXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSW9uaWMuVXNlcjtcbiAgICB9XG4gIF0pXG5cbiAgLnJ1bihbZnVuY3Rpb24oKSB7XG4gICAgSW9uaWMuaW8oKTtcbiAgfV0pO1xufVxuXG4iLCIvLyBBZGQgQW5ndWxhciBpbnRlZ3JhdGlvbnMgaWYgQW5ndWxhciBpcyBhdmFpbGFibGVcbmlmICgodHlwZW9mIGFuZ3VsYXIgPT09ICdvYmplY3QnKSAmJiBhbmd1bGFyLm1vZHVsZSkge1xuXG4gIHZhciBJb25pY0FuZ3VsYXJEZXBsb3kgPSBudWxsO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCdpb25pYy5zZXJ2aWNlLmRlcGxveScsIFtdKVxuXG4gIC5mYWN0b3J5KCckaW9uaWNEZXBsb3knLCBbZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFJb25pY0FuZ3VsYXJEZXBsb3kpIHtcbiAgICAgIElvbmljQW5ndWxhckRlcGxveSA9IG5ldyBJb25pYy5EZXBsb3koKTtcbiAgICB9XG4gICAgcmV0dXJuIElvbmljQW5ndWxhckRlcGxveTtcbiAgfV0pO1xufVxuIiwidmFyIEFuYWx5dGljcyA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2FuYWx5dGljcy9hbmFseXRpY3NcIikuQW5hbHl0aWNzO1xudmFyIEFwcCA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2NvcmUvYXBwXCIpLkFwcDtcbnZhciBBdXRoID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvYXV0aC9hdXRoXCIpLkF1dGg7XG52YXIgQnVja2V0U3RvcmFnZSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2FuYWx5dGljcy9zdG9yYWdlXCIpLkJ1Y2tldFN0b3JhZ2U7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvY29yZS9jb25maWdcIikuY29uZmlnO1xudmFyIERPTVNlcmlhbGl6ZXIgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9hbmFseXRpY3Mvc2VyaWFsaXplcnNcIikuRE9NU2VyaWFsaXplcjtcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2NvcmUvZGF0YS10eXBlc1wiKS5EYXRhVHlwZTtcbnZhciBEZXBsb3kgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9kZXBsb3kvZGVwbG95XCIpLkRlcGxveTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9jb3JlL2V2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XG52YXIgSW9uaWNQbGF0Zm9ybSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2NvcmUvY29yZVwiKS5Jb25pY1BsYXRmb3JtO1xudmFyIExvZ2dlciA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2NvcmUvbG9nZ2VyXCIpLkxvZ2dlcjtcbnZhciBQdXNoID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvcHVzaC9wdXNoXCIpLlB1c2g7XG52YXIgUHVzaE1lc3NhZ2UgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9wdXNoL3B1c2gtbWVzc2FnZVwiKS5QdXNoTWVzc2FnZTtcbnZhciBQdXNoVG9rZW4gPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9wdXNoL3B1c2gtdG9rZW5cIikuUHVzaFRva2VuO1xudmFyIFN0b3JhZ2UgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9jb3JlL3N0b3JhZ2VcIikuU3RvcmFnZTtcbnZhciBVc2VyID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvY29yZS91c2VyXCIpLlVzZXI7XG52YXIgcHJvbWlzZSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2NvcmUvcHJvbWlzZVwiKTtcblxuLy8gRGVjbGFyZSB0aGUgd2luZG93IG9iamVjdFxud2luZG93LklvbmljID0gd2luZG93LklvbmljIHx8IHt9O1xuXG4vLyBJb25pYyBNb2R1bGVzXG5Jb25pYy5Db3JlID0gSW9uaWNQbGF0Zm9ybTtcbklvbmljLlVzZXIgPSBVc2VyO1xuSW9uaWMuQW5hbHl0aWNzID0gQW5hbHl0aWNzO1xuSW9uaWMuQXV0aCA9IEF1dGg7XG5Jb25pYy5EZXBsb3kgPSBEZXBsb3k7XG5Jb25pYy5QdXNoID0gUHVzaDtcbklvbmljLlB1c2hUb2tlbiA9IFB1c2hUb2tlbjtcbklvbmljLlB1c2hNZXNzYWdlID0gUHVzaE1lc3NhZ2U7XG5cbi8vIERhdGFUeXBlIE5hbWVzcGFjZVxuSW9uaWMuRGF0YVR5cGUgPSBEYXRhVHlwZTtcbklvbmljLkRhdGFUeXBlcyA9IERhdGFUeXBlLmdldE1hcHBpbmcoKTtcblxuLy8gSU8gTmFtZXNwYWNlXG5Jb25pYy5JTyA9IHt9O1xuSW9uaWMuSU8uQXBwID0gQXBwO1xuSW9uaWMuSU8uRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuSW9uaWMuSU8uTG9nZ2VyID0gTG9nZ2VyO1xuSW9uaWMuSU8uUHJvbWlzZSA9IHByb21pc2UuUHJvbWlzZTtcbklvbmljLklPLkRlZmVycmVkUHJvbWlzZSA9IHByb21pc2UuRGVmZXJyZWRQcm9taXNlO1xuSW9uaWMuSU8uU3RvcmFnZSA9IFN0b3JhZ2U7XG5Jb25pYy5JTy5Db25maWcgPSBjb25maWc7XG5Jb25pYy5JTy5TZXR0aW5ncyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuXG4vLyBBbmFseXRpYyBTdG9yYWdlIE5hbWVzcGFjZVxuSW9uaWMuQW5hbHl0aWNTdG9yYWdlID0ge307XG5Jb25pYy5BbmFseXRpY1N0b3JhZ2UuQnVja2V0U3RvcmFnZSA9IEJ1Y2tldFN0b3JhZ2U7XG5cbi8vIEFuYWx5dGljIFNlcmlhbGl6ZXJzIE5hbWVzcGFjZVxuSW9uaWMuQW5hbHl0aWNTZXJpYWxpemVycyA9IHt9O1xuSW9uaWMuQW5hbHl0aWNTZXJpYWxpemVycy5ET01TZXJpYWxpemVyID0gRE9NU2VyaWFsaXplcjtcblxuXG4vLyBQcm92aWRlciBhIHNpbmdsZSBzdG9yYWdlIGZvciBzZXJ2aWNlcyB0aGF0IGhhdmUgcHJldmlvdXNseSBiZWVuIHJlZ2lzdGVyZWRcbnZhciBzZXJ2aWNlU3RvcmFnZSA9IHt9O1xuXG5Jb25pYy5pbyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSW9uaWMuQ29yZTtcbn07XG5cbklvbmljLmdldFNlcnZpY2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0eXBlb2Ygc2VydmljZVN0b3JhZ2VbbmFtZV0gPT09ICd1bmRlZmluZWQnIHx8ICFzZXJ2aWNlU3RvcmFnZVtuYW1lXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc2VydmljZVN0b3JhZ2VbbmFtZV07XG59O1xuXG5Jb25pYy5hZGRTZXJ2aWNlID0gZnVuY3Rpb24obmFtZSwgc2VydmljZSwgZm9yY2UpIHtcbiAgaWYgKHNlcnZpY2UgJiYgdHlwZW9mIHNlcnZpY2VTdG9yYWdlW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgIHNlcnZpY2VTdG9yYWdlW25hbWVdID0gc2VydmljZTtcbiAgfSBlbHNlIGlmIChzZXJ2aWNlICYmIGZvcmNlKSB7XG4gICAgc2VydmljZVN0b3JhZ2VbbmFtZV0gPSBzZXJ2aWNlO1xuICB9XG59O1xuXG5Jb25pYy5yZW1vdmVTZXJ2aWNlID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAodHlwZW9mIHNlcnZpY2VTdG9yYWdlW25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlbGV0ZSBzZXJ2aWNlU3RvcmFnZVtuYW1lXTtcbiAgfVxufTtcbiIsIi8vIEFkZCBBbmd1bGFyIGludGVncmF0aW9ucyBpZiBBbmd1bGFyIGlzIGF2YWlsYWJsZVxuaWYgKCh0eXBlb2YgYW5ndWxhciA9PT0gJ29iamVjdCcpICYmIGFuZ3VsYXIubW9kdWxlKSB7XG5cbiAgdmFyIElvbmljQW5ndWxhclB1c2ggPSBudWxsO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCdpb25pYy5zZXJ2aWNlLnB1c2gnLCBbXSlcblxuICAvKipcbiAgICogSW9uaWNQdXNoQWN0aW9uIFNlcnZpY2VcbiAgICpcbiAgICogQSB1dGlsaXR5IHNlcnZpY2UgdG8ga2ljayBvZmYgbWlzYyBmZWF0dXJlcyBhcyBwYXJ0IG9mIHRoZSBJb25pYyBQdXNoIHNlcnZpY2VcbiAgICovXG4gIC5mYWN0b3J5KCckaW9uaWNQdXNoQWN0aW9uJywgWyckc3RhdGUnLCBmdW5jdGlvbigkc3RhdGUpIHtcblxuICAgIGZ1bmN0aW9uIFB1c2hBY3Rpb25TZXJ2aWNlKCkge31cblxuICAgIC8qKlxuICAgICAqIFN0YXRlIE5hdmlnYXRpb25cbiAgICAgKlxuICAgICAqIEF0dGVtcHRzIHRvIG5hdmlnYXRlIHRvIGEgbmV3IHZpZXcgaWYgYSBwdXNoIG5vdGlmaWNhdGlvbiBwYXlsb2FkIGNvbnRhaW5zOlxuICAgICAqXG4gICAgICogICAtICRzdGF0ZSB7U3RyaW5nfSBUaGUgc3RhdGUgbmFtZSAoZS5nICd0YWIuY2hhdHMnKVxuICAgICAqICAgLSAkc3RhdGVQYXJhbXMge09iamVjdH0gUHJvdmlkZWQgc3RhdGUgKHVybCkgcGFyYW1zXG4gICAgICpcbiAgICAgKiBGaW5kIG1vcmUgaW5mbyBhYm91dCBzdGF0ZSBuYXZpZ2F0aW9uIGFuZCBwYXJhbXM6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL3dpa2lcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBub3RpZmljYXRpb24gTm90aWZpY2F0aW9uIE9iamVjdFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgUHVzaEFjdGlvblNlcnZpY2UucHJvdG90eXBlLm5vdGlmaWNhdGlvbk5hdmlnYXRpb24gPSBmdW5jdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vdGlmaWNhdGlvbi5wYXlsb2FkLiRzdGF0ZSB8fCBmYWxzZTtcbiAgICAgIHZhciBzdGF0ZVBhcmFtcyA9IG5vdGlmaWNhdGlvbi5wYXlsb2FkLiRzdGF0ZVBhcmFtcyB8fCB7fTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAkc3RhdGUuZ28oc3RhdGUsIHN0YXRlUGFyYW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQdXNoQWN0aW9uU2VydmljZSgpO1xuICB9XSlcblxuICAuZmFjdG9yeSgnJGlvbmljUHVzaCcsIFtmdW5jdGlvbigpIHtcbiAgICBpZiAoIUlvbmljQW5ndWxhclB1c2gpIHtcbiAgICAgIElvbmljQW5ndWxhclB1c2ggPSBuZXcgSW9uaWMuUHVzaCh7ICdkZWZlckluaXQnOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gSW9uaWNBbmd1bGFyUHVzaDtcbiAgfV0pXG5cbiAgLnJ1bihbJyRpb25pY0NvcmUnLCAnJGlvbmljUHVzaCcsICckaW9uaWNQdXNoQWN0aW9uJywgZnVuY3Rpb24oJGlvbmljQ29yZSwgJGlvbmljUHVzaCwgJGlvbmljUHVzaEFjdGlvbikge1xuICAgIC8vIFRoaXMgaXMgd2hhdCBraWNrcyBvZmYgdGhlIHN0YXRlIHJlZGlyZWN0aW9uIHdoZW4gYSBwdXNoIG5vdGlmaWNhaXRvbiBoYXMgdGhlIHJlbGV2YW50IGRldGFpbHNcbiAgICAkaW9uaWNDb3JlLmVtaXR0ZXIub24oJ3B1c2g6cHJvY2Vzc05vdGlmaWNhdGlvbicsIGZ1bmN0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgbm90aWZpY2F0aW9uID0gSW9uaWMuUHVzaE1lc3NhZ2UuZnJvbVBsdWdpbkpTT04obm90aWZpY2F0aW9uKTtcbiAgICAgIGlmIChub3RpZmljYXRpb24gJiYgbm90aWZpY2F0aW9uLmFwcCkge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLmFwcC5hc2xlZXAgPT09IHRydWUgfHwgbm90aWZpY2F0aW9uLmFwcC5jbG9zZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAkaW9uaWNQdXNoQWN0aW9uLm5vdGlmaWNhdGlvbk5hdmlnYXRpb24obm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gIH1dKTtcbn1cbiJdfQ==
